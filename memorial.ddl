-- Nota: El comando CREATE DATABASE y USE son manejados de forma diferente en Oracle.
-- Generalmente, te conectas a un esquema/usuario específico dentro de una base de datos.
-- Las cláusulas CHARACTER SET y COLLATE se definen a nivel de base de datos/tablespace en Oracle.

CREATE TABLE auditoria_cambios (
  ID_Auditoria                 NUMBER(19) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Nombre_Tabla_Afectada        VARCHAR2(100 CHAR) NOT NULL,
  ID_Registro_Afectado_PK1     VARCHAR2(255 CHAR),
  ID_Registro_Afectado_PK2     VARCHAR2(255 CHAR),
  Correo_Usuario_Responsable   VARCHAR2(255 CHAR),
  IP_Origen_Cambio             VARCHAR2(45 CHAR),
  Tipo_Operacion_Realizada     VARCHAR2(20 CHAR) NOT NULL, -- INSERT,UPDATE,DELETE,LOGIN_FALLIDO,LOGIN_EXITOSO,ACCESO_REPORTE
  Fecha_Hora_Operacion         TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  Valores_Originales_Registro  CLOB,
  Valores_Nuevos_Registro      CLOB,
  Descripcion_Adicional_Cambio CLOB,
  User_Agent_Navegador         VARCHAR2(512 CHAR),
  CONSTRAINT pk_auditoria_cambios PRIMARY KEY (ID_Auditoria),
  CONSTRAINT chk_auditoria_tipo_op CHECK (Tipo_Operacion_Realizada IN ('INSERT','UPDATE','DELETE','LOGIN_FALLIDO','LOGIN_EXITOSO','ACCESO_REPORTE')),
  CONSTRAINT chk_auditoria_val_orig_json CHECK (Valores_Originales_Registro IS NULL OR Valores_Originales_Registro IS JSON),
  CONSTRAINT chk_auditoria_val_nuevos_json CHECK (Valores_Nuevos_Registro IS NULL OR Valores_Nuevos_Registro IS JSON)
);

COMMENT ON TABLE auditoria_cambios IS 'Tabla para registrar un historial detallado de cambios y eventos importantes en el sistema.';
COMMENT ON COLUMN auditoria_cambios.Nombre_Tabla_Afectada IS 'Nombre de la tabla que fue modificada.';
COMMENT ON COLUMN auditoria_cambios.ID_Registro_Afectado_PK1 IS 'Valor de la clave primaria (o parte 1 si es compuesta) del registro afectado.';
COMMENT ON COLUMN auditoria_cambios.ID_Registro_Afectado_PK2 IS 'Valor de la parte 2 de la clave primaria si es compuesta.';
COMMENT ON COLUMN auditoria_cambios.Correo_Usuario_Responsable IS 'Usuario del sistema que realizó el cambio (FK a Usuario_Sistema.Correo_Electronico).';
COMMENT ON COLUMN auditoria_cambios.IP_Origen_Cambio IS 'Dirección IP desde donde se originó el cambio (IPv4 o IPv6).';
COMMENT ON COLUMN auditoria_cambios.Tipo_Operacion_Realizada IS 'Tipo de operación o evento auditado.';
COMMENT ON COLUMN auditoria_cambios.Fecha_Hora_Operacion IS 'Fecha y hora exactas en que se realizó la operación.';
COMMENT ON COLUMN auditoria_cambios.Valores_Originales_Registro IS 'Valores del registro antes del cambio (formato JSON), aplicable para UPDATE y DELETE.';
COMMENT ON COLUMN auditoria_cambios.Valores_Nuevos_Registro IS 'Valores del registro después del cambio (formato JSON), aplicable para INSERT y UPDATE.';
COMMENT ON COLUMN auditoria_cambios.Descripcion_Adicional_Cambio IS 'Descripción adicional, justificación del cambio o detalles del evento.';
COMMENT ON COLUMN auditoria_cambios.User_Agent_Navegador IS 'Información del User-Agent del cliente que realizó la acción.';

CREATE TABLE pais (
  ID_Pais               NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Nombre_Pais           VARCHAR2(100 CHAR) NOT NULL,
  Codigo_ISO_Alfa2      CHAR(2 CHAR),
  Codigo_ISO_Alfa3      CHAR(3 CHAR),
  Continente            VARCHAR2(50 CHAR),
  Fecha_Creacion        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_pais PRIMARY KEY (ID_Pais),
  CONSTRAINT uq_pais_nombre UNIQUE (Nombre_Pais),
  CONSTRAINT uq_pais_iso_alfa2 UNIQUE (Codigo_ISO_Alfa2),
  CONSTRAINT uq_pais_iso_alfa3 UNIQUE (Codigo_ISO_Alfa3)
);
COMMENT ON TABLE pais IS 'Catálogo de países involucrados o de referencia.';
COMMENT ON COLUMN pais.Nombre_Pais IS 'Nombre oficial y común del país.';
COMMENT ON COLUMN pais.Codigo_ISO_Alfa2 IS 'Código ISO 3166-1 Alfa-2 del país (Ej: US, DE, GB).';
COMMENT ON COLUMN pais.Codigo_ISO_Alfa3 IS 'Código ISO 3166-1 Alfa-3 del país (Ej: USA, DEU, GBR).';
COMMENT ON COLUMN pais.Continente IS 'Continente al que pertenece el país.';
COMMENT ON COLUMN pais.Fecha_Creacion IS 'Fecha de creación del registro en la base de datos.';
COMMENT ON COLUMN pais.Fecha_Actualizacion IS 'Fecha de última actualización del registro en la base de datos.';

CREATE TABLE lugar (
  ID_Lugar             NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  ID_Pais              NUMBER(10) NOT NULL,
  Nombre_Lugar         VARCHAR2(255 CHAR) NOT NULL,
  Tipo_Lugar           VARCHAR2(50 CHAR),
  Coordenadas_Lat      NUMBER(10,8),
  Coordenadas_Lon      NUMBER(11,8),
  Altitud_Metros       NUMBER(10),
  Notas_Lugar          CLOB,
  Fecha_Creacion       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_lugar PRIMARY KEY (ID_Lugar),
  CONSTRAINT uq_lugar_pais_nombre_tipo UNIQUE (ID_Pais, Nombre_Lugar, Tipo_Lugar),
  CONSTRAINT fk_lugar_pais FOREIGN KEY (ID_Pais) REFERENCES pais (ID_Pais) -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE lugar IS 'Catálogo de lugares geográficos relevantes (nacimiento, muerte, batalla, inhumación).';
COMMENT ON COLUMN lugar.ID_Pais IS 'País al que pertenece el lugar (FK a Pais.ID_Pais).';
COMMENT ON COLUMN lugar.Nombre_Lugar IS 'Nombre del lugar (ciudad, pueblo, villa, región, provincia, estado, etc.).';
COMMENT ON COLUMN lugar.Tipo_Lugar IS 'Tipo de lugar (Ej: Ciudad, Pueblo, Provincia, Estado, Región Geográfica).';
COMMENT ON COLUMN lugar.Coordenadas_Lat IS 'Latitud geográfica del lugar (formato decimal).';
COMMENT ON COLUMN lugar.Coordenadas_Lon IS 'Longitud geográfica del lugar (formato decimal).';
COMMENT ON COLUMN lugar.Altitud_Metros IS 'Altitud del lugar en metros sobre el nivel del mar (opcional).';
COMMENT ON COLUMN lugar.Notas_Lugar IS 'Notas adicionales o históricas sobre el lugar.';

CREATE TABLE causa_muerte (
  ID_Causa_Muerte           NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Descripcion_Causa         VARCHAR2(255 CHAR) NOT NULL,
  Categoria_Causa           VARCHAR2(30 CHAR) DEFAULT 'Desconocida' NOT NULL, -- Combate Directo,Consecuencia de Combate,Enfermedad,Accidente,Cautiverio/Prisión,Suicidio,Ejecución,Desconocida,Otra
  Requiere_Detalle_Adicional NUMBER(1) DEFAULT 0 NOT NULL,
  Fecha_Creacion            TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_causa_muerte PRIMARY KEY (ID_Causa_Muerte),
  CONSTRAINT uq_causa_muerte_desc UNIQUE (Descripcion_Causa),
  CONSTRAINT chk_causa_muerte_cat CHECK (Categoria_Causa IN ('Combate Directo','Consecuencia de Combate','Enfermedad','Accidente','Cautiverio/Prisión','Suicidio','Ejecución','Desconocida','Otra')),
  CONSTRAINT chk_causa_muerte_req_det CHECK (Requiere_Detalle_Adicional IN (0,1))
);
COMMENT ON TABLE causa_muerte IS 'Catálogo estandarizado de causas de muerte.';
COMMENT ON COLUMN causa_muerte.Descripcion_Causa IS 'Descripción detallada de la causa de muerte (Ej: Caído en combate por artillería, Herida de bala infectada, Neumonía en cautiverio).';
COMMENT ON COLUMN causa_muerte.Categoria_Causa IS 'Categoría general de la causa de muerte.';
COMMENT ON COLUMN causa_muerte.Requiere_Detalle_Adicional IS 'Indica si esta causa usualmente requiere más detalles en notas.';

CREATE TABLE rama_ejercito (
  ID_Rama_Ejercito    NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Nombre_Rama         VARCHAR2(100 CHAR) NOT NULL,
  Descripcion_Rama    CLOB,
  Siglas_Rama         VARCHAR2(20 CHAR),
  Fecha_Creacion      TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_rama_ejercito PRIMARY KEY (ID_Rama_Ejercito),
  CONSTRAINT uq_rama_ejercito_nombre UNIQUE (Nombre_Rama),
  CONSTRAINT uq_rama_ejercito_siglas UNIQUE (Siglas_Rama)
);
COMMENT ON TABLE rama_ejercito IS 'Catálogo de las diferentes ramas de las fuerzas armadas.';
COMMENT ON COLUMN rama_ejercito.Nombre_Rama IS 'Nombre de la rama del ejército (Ej: Ejército de Tierra, Marina de Guerra, Fuerza Aérea, Fuerzas Especiales, Waffen-SS, Guardia Nacional).';
COMMENT ON COLUMN rama_ejercito.Descripcion_Rama IS 'Descripción detallada de las funciones y características de la rama del ejército.';
COMMENT ON COLUMN rama_ejercito.Siglas_Rama IS 'Siglas o abreviatura común de la rama.';

CREATE TABLE soldado (
  ID_Soldado                     NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Nombres                        VARCHAR2(150 CHAR) NOT NULL,
  Patronimico                    VARCHAR2(100 CHAR),
  Apellidos                      VARCHAR2(150 CHAR) NOT NULL,
  Nombre_Completo_Busqueda       VARCHAR2(402 CHAR) GENERATED ALWAYS AS (TRIM(Nombres || DECODE(Patronimico, NULL, '', ' ' || Patronimico) || ' ' || Apellidos)),
  Sexo                           VARCHAR2(15 CHAR) DEFAULT 'Desconocido' NOT NULL, -- Masculino,Femenino,Desconocido
  ID_Pais_Origen                 NUMBER(10) NOT NULL,
  ID_Lugar_Nacimiento            NUMBER(10) NOT NULL,
  Fecha_Nacimiento               DATE NOT NULL,
  Fecha_Nacimiento_Precision     VARCHAR2(15 CHAR) DEFAULT 'Exacta' NOT NULL, -- Exacta,Mes y Año,Solo Año,Aproximada
  ID_Lugar_Muerte                NUMBER(10),
  Fecha_Muerte                   DATE,
  Fecha_Muerte_Precision         VARCHAR2(20 CHAR) DEFAULT 'Exacta' NOT NULL, -- Exacta,Mes y Año,Solo Año,Aproximada,Declarado Muerto
  ID_Causa_Muerte                NUMBER(10),
  ID_Rama_Ejercito               NUMBER(10),
  Numero_Identificacion_Militar  VARCHAR2(50 CHAR),
  Notas_Adicionales_Soldado      CLOB,
  Fotografia_URL                 VARCHAR2(2048 CHAR),
  Estado_Registro                VARCHAR2(30 CHAR) DEFAULT 'Pendiente Verificacion' NOT NULL, -- Verificado,Pendiente Verificacion,Incompleto,Disputado
  Fuente_Informacion_Principal   CLOB,
  Fecha_Creacion                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion            TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_soldado PRIMARY KEY (ID_Soldado),
  CONSTRAINT uq_soldado_num_id_militar UNIQUE (Numero_Identificacion_Militar),
  CONSTRAINT chk_soldado_sexo CHECK (Sexo IN ('Masculino','Femenino','Desconocido')),
  CONSTRAINT chk_soldado_fec_nac_prec CHECK (Fecha_Nacimiento_Precision IN ('Exacta','Mes y Año','Solo Año','Aproximada')),
  CONSTRAINT chk_soldado_fec_muer_prec CHECK (Fecha_Muerte_Precision IN ('Exacta','Mes y Año','Solo Año','Aproximada','Declarado Muerto')),
  CONSTRAINT chk_soldado_estado_reg CHECK (Estado_Registro IN ('Verificado','Pendiente Verificacion','Incompleto','Disputado')),
  CONSTRAINT fk_soldado_pais_origen FOREIGN KEY (ID_Pais_Origen) REFERENCES pais (ID_Pais), -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldado_lugar_nac FOREIGN KEY (ID_Lugar_Nacimiento) REFERENCES lugar (ID_Lugar), -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldado_lugar_fall FOREIGN KEY (ID_Lugar_Muerte) REFERENCES lugar (ID_Lugar) ON DELETE SET NULL, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldado_causa_fall FOREIGN KEY (ID_Causa_Muerte) REFERENCES causa_muerte (ID_Causa_Muerte) ON DELETE SET NULL, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldado_rama_mil FOREIGN KEY (ID_Rama_Ejercito) REFERENCES rama_ejercito (ID_Rama_Ejercito) ON DELETE SET NULL -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE soldado IS 'Información detallada y central de los soldados caídos durante la SGM.';
COMMENT ON COLUMN soldado.Nombres IS 'Nombres de pila del soldado.';
COMMENT ON COLUMN soldado.Patronimico IS 'Segundo nombre o patronímico, si aplica (común en algunas culturas).';
COMMENT ON COLUMN soldado.Apellidos IS 'Apellidos del soldado.';
COMMENT ON COLUMN soldado.Nombre_Completo_Busqueda IS 'Campo calculado para facilitar búsquedas de nombre completo.';
COMMENT ON COLUMN soldado.ID_Pais_Origen IS 'País de origen (nacionalidad al momento del servicio) del soldado (FK a Pais.ID_Pais).';
COMMENT ON COLUMN soldado.ID_Lugar_Nacimiento IS 'Lugar de nacimiento del soldado (FK a Lugar.ID_Lugar).';
COMMENT ON COLUMN soldado.Fecha_Nacimiento IS 'Fecha de nacimiento del soldado.';
COMMENT ON COLUMN soldado.ID_Lugar_Muerte IS 'Lugar donde murió el soldado (FK a Lugar.ID_Lugar, puede ser nulo si se desconoce).';
COMMENT ON COLUMN soldado.Fecha_Muerte IS 'Fecha de muerte del soldado (puede ser nula si se desconoce).';
COMMENT ON COLUMN soldado.ID_Causa_Muerte IS 'Causa de la muerte del soldado (FK a Causa_Muerte.ID_Causa_Muerte).';
COMMENT ON COLUMN soldado.ID_Rama_Ejercito IS 'Rama del ejército a la que perteneció el soldado principalmente (FK a Rama_Ejercito.ID_Rama_Ejercito).';
COMMENT ON COLUMN soldado.Numero_Identificacion_Militar IS 'Número de servicio o identificación militar único del soldado, si se conoce.';
COMMENT ON COLUMN soldado.Notas_Adicionales_Soldado IS 'Espacio para cualquier información adicional relevante no estructurada sobre el soldado.';
COMMENT ON COLUMN soldado.Fotografia_URL IS 'URL a una fotografía del soldado, si existe y está permitida.';
COMMENT ON COLUMN soldado.Estado_Registro IS 'Estado del registro.';
COMMENT ON COLUMN soldado.Fuente_Informacion_Principal IS 'Referencia a la fuente principal de donde se obtuvo la información del soldado.';

CREATE INDEX idx_soldado_nombrecompleto ON soldado (Nombre_Completo_Busqueda);
CREATE INDEX idx_soldado_apellidosnombres ON soldado (Apellidos, Nombres);
CREATE INDEX idx_soldado_fechanac ON soldado (Fecha_Nacimiento);
CREATE INDEX idx_soldado_fechafall ON soldado (Fecha_Muerte);
CREATE INDEX idx_soldado_paisorg ON soldado (ID_Pais_Origen);
CREATE INDEX idx_soldado_numident ON soldado (Numero_Identificacion_Militar);


CREATE TABLE informacion_muerte_transporte (
  ID_Muerte_Transporte                 NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  ID_Soldado                           NUMBER(10) NOT NULL,
  Tipo_Transporte_Accidente            VARCHAR2(100 CHAR) NOT NULL,
  Naturaleza_Mision_Transporte         VARCHAR2(100 CHAR),
  Nombre_O_Identificador_Transporte    VARCHAR2(255 CHAR),
  Ubicacion_Geografica_Transporte_Muerte CLOB NOT NULL,
  Coordenadas_Transporte_Muerte_Lat    NUMBER(10,8),
  Coordenadas_Transporte_Muerte_Lon    NUMBER(11,8),
  Causa_Incidente_Transporte           CLOB,
  Fecha_Creacion                       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion                  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_inf_muerte_transporte PRIMARY KEY (ID_Muerte_Transporte),
  CONSTRAINT uq_inf_muerte_trans_idsold UNIQUE (ID_Soldado),
  CONSTRAINT fk_muertetrans_refsoldado FOREIGN KEY (ID_Soldado) REFERENCES soldado (ID_Soldado) ON DELETE CASCADE -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE informacion_muerte_transporte IS 'Detalles específicos si la muerte del soldado ocurrió en un medio de transporte durante una operación o accidente.';
COMMENT ON COLUMN informacion_muerte_transporte.ID_Soldado IS 'Identificador del soldado (FK a Soldado.ID_Soldado).';
COMMENT ON COLUMN informacion_muerte_transporte.Tipo_Transporte_Accidente IS 'Tipo de transporte donde ocurrió la muerte (Ej: Navío, Submarino, Avión de Combate, Bombardero, Tanque, Tren, Camión).';
COMMENT ON COLUMN informacion_muerte_transporte.Naturaleza_Mision_Transporte IS 'Naturaleza o función del transporte/misión (Ej: Combate, Transporte de Tropas, Carga, Patrulla, Reconocimiento).';
COMMENT ON COLUMN informacion_muerte_transporte.Nombre_O_Identificador_Transporte IS 'Nombre o número de identificación del navío, avión, etc., si se conoce (Ej: U-Boot U-96, B-17 "Memphis Belle").';
COMMENT ON COLUMN informacion_muerte_transporte.Ubicacion_Geografica_Transporte_Muerte IS 'Descripción de la ubicación geográfica del transporte al momento de ocurrir la muerte (Ej: "Atlántico Norte, cerca de Islandia", "Sobrevolando Dresde").';
COMMENT ON COLUMN informacion_muerte_transporte.Coordenadas_Transporte_Muerte_Lat IS 'Latitud geográfica aproximada del transporte al momento de la muerte.';
COMMENT ON COLUMN informacion_muerte_transporte.Coordenadas_Transporte_Muerte_Lon IS 'Longitud geográfica aproximada del transporte al momento de la muerte.';
COMMENT ON COLUMN informacion_muerte_transporte.Causa_Incidente_Transporte IS 'Causa del incidente que llevó a la muerte en el transporte (Ej: Derribado por fuego antiaéreo, Hundido por torpedo, Accidente de aterrizaje).';


CREATE TABLE lugar_inhumacion (
  ID_Soldado                          NUMBER(10) NOT NULL,
  ID_Pais_Inhumacion                  NUMBER(10),
  ID_Lugar_Inhumacion_Detallado       NUMBER(10),
  Lugar_Detallado_Texto_Inhumacion    VARCHAR2(255 CHAR),
  Nombre_Cementerio_Memorial          VARCHAR2(255 CHAR),
  Tipo_Sitio_Inhumacion               VARCHAR2(30 CHAR) DEFAULT 'Desconocido' NOT NULL, -- Tumba Individual,Fosa Común,Memorial (Sin Restos),Cenotafio,Desconocido,Perdido en Mar/Aire
  Ubicacion_Exacta_Tumba              VARCHAR2(255 CHAR),
  Coordenadas_Sitio_Lat               NUMBER(10,8),
  Coordenadas_Sitio_Lon               NUMBER(11,8),
  Es_Inhumacion_Desconocida_Confirmado NUMBER(1) DEFAULT 0 NOT NULL,
  Anotacion_Lugar_Desconocido         CLOB,
  Fotografia_Tumba_URL                VARCHAR2(2048 CHAR),
  Fecha_Creacion                      TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_lugar_inhumacion PRIMARY KEY (ID_Soldado),
  CONSTRAINT chk_lugar_inh_tipo_sitio CHECK (Tipo_Sitio_Inhumacion IN ('Tumba Individual','Fosa Común','Memorial (Sin Restos)','Cenotafio','Desconocido','Perdido en Mar/Aire')),
  CONSTRAINT chk_lugar_inh_es_desc CHECK (Es_Inhumacion_Desconocida_Confirmado IN (0,1)),
  CONSTRAINT fk_lugarinh_refpais FOREIGN KEY (ID_Pais_Inhumacion) REFERENCES pais (ID_Pais) ON DELETE SET NULL, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_lugarinh_reflugar FOREIGN KEY (ID_Lugar_Inhumacion_Detallado) REFERENCES lugar (ID_Lugar) ON DELETE SET NULL, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_lugarinh_refsoldado FOREIGN KEY (ID_Soldado) REFERENCES soldado (ID_Soldado) ON DELETE CASCADE -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE lugar_inhumacion IS 'Información detallada sobre el lugar de inhumación o conmemoración del soldado.';
COMMENT ON COLUMN lugar_inhumacion.ID_Soldado IS 'Clave primaria y foránea al soldado (FK a Soldado.ID_Soldado).';
COMMENT ON COLUMN lugar_inhumacion.ID_Pais_Inhumacion IS 'País donde fue inhumado el soldado (FK a Pais.ID_Pais).';
COMMENT ON COLUMN lugar_inhumacion.ID_Lugar_Inhumacion_Detallado IS 'FK a Lugar para el lugar específico (pueblo, villa) de inhumación.';
COMMENT ON COLUMN lugar_inhumacion.Lugar_Detallado_Texto_Inhumacion IS 'Descripción textual del estado, pueblo o villa, si no se usa FK o como complemento.';
COMMENT ON COLUMN lugar_inhumacion.Nombre_Cementerio_Memorial IS 'Nombre del cementerio o memorial donde fue inhumado o se le conmemora.';
COMMENT ON COLUMN lugar_inhumacion.Tipo_Sitio_Inhumacion IS 'Tipo de sitio de inhumación.';
COMMENT ON COLUMN lugar_inhumacion.Ubicacion_Exacta_Tumba IS 'Ubicación específica de la tumba/placa dentro del cementerio/memorial (Ej: Sección A, Fila 10, Tumba 5).';
COMMENT ON COLUMN lugar_inhumacion.Coordenadas_Sitio_Lat IS 'Latitud geográfica del cementerio/memorial.';
COMMENT ON COLUMN lugar_inhumacion.Coordenadas_Sitio_Lon IS 'Longitud geográfica del cementerio/memorial.';
COMMENT ON COLUMN lugar_inhumacion.Es_Inhumacion_Desconocida_Confirmado IS 'TRUE si se ha confirmado que se desconoce el lugar exacto de inhumación.';
COMMENT ON COLUMN lugar_inhumacion.Anotacion_Lugar_Desconocido IS 'Nota explicativa si el lugar es desconocido. Usualmente indica que se referencia el lugar de muerte o último conocido.';

CREATE TABLE medalla (
  ID_Medalla                 NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Nombre_Medalla             VARCHAR2(255 CHAR) NOT NULL,
  Descripcion_Medalla        CLOB,
  ID_Pais_Otorga             NUMBER(10),
  Criterio_Otorgamiento      CLOB,
  Tipo_Condecoracion         VARCHAR2(30 CHAR) DEFAULT 'Otra' NOT NULL, -- Valor,Servicio Meritorio,Campaña,Herida,Antigüedad,Conmemorativa,Otra
  Imagen_Medalla_URL         VARCHAR2(2048 CHAR),
  Fecha_Institucion_Medalla  DATE,
  Fecha_Creacion             TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_medalla PRIMARY KEY (ID_Medalla),
  CONSTRAINT uq_medalla_nombre_paisotorga UNIQUE (Nombre_Medalla, ID_Pais_Otorga),
  CONSTRAINT chk_medalla_tipo_condec CHECK (Tipo_Condecoracion IN ('Valor','Servicio Meritorio','Campaña','Herida','Antigüedad','Conmemorativa','Otra')),
  CONSTRAINT fk_medalla_paisotorga FOREIGN KEY (ID_Pais_Otorga) REFERENCES pais (ID_Pais) ON DELETE SET NULL -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE medalla IS 'Catálogo de medallas, condecoraciones y distintivos militares.';
COMMENT ON COLUMN medalla.Nombre_Medalla IS 'Nombre oficial de la medalla, condecoración o distintivo.';
COMMENT ON COLUMN medalla.Descripcion_Medalla IS 'Descripción de la medalla, su significado y simbolismo.';
COMMENT ON COLUMN medalla.ID_Pais_Otorga IS 'País que otorga la medalla (FK a Pais.ID_Pais).';
COMMENT ON COLUMN medalla.Criterio_Otorgamiento IS 'Criterios generales o motivos comunes para su otorgamiento.';
COMMENT ON COLUMN medalla.Tipo_Condecoracion IS 'Tipo de condecoración.';
COMMENT ON COLUMN medalla.Imagen_Medalla_URL IS 'URL a una imagen representativa de la medalla.';
COMMENT ON COLUMN medalla.Fecha_Institucion_Medalla IS 'Fecha en que la medalla fue instituida.';


CREATE TABLE campana_militar (
  ID_Campana                  NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Nombre_Oficial_Campana      VARCHAR2(255 CHAR) NOT NULL,
  Nombre_Codigo_Operacion     VARCHAR2(255 CHAR),
  Descripcion_Campana         CLOB,
  Fecha_Inicio_Campana        DATE,
  Fecha_Fin_Campana           DATE,
  Objetivo_Campana            CLOB,
  Resultado_Campana           CLOB,
  Teatro_Operaciones          VARCHAR2(150 CHAR),
  Paises_Principales_Eje      CLOB,
  Paises_Principales_Aliados  CLOB,
  Fecha_Creacion              TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion         TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_campana_militar PRIMARY KEY (ID_Campana),
  CONSTRAINT uq_campana_nomoficial_inicio UNIQUE (Nombre_Oficial_Campana, Fecha_Inicio_Campana),
  CONSTRAINT uq_campana_nomcodigo UNIQUE (Nombre_Codigo_Operacion)
);
COMMENT ON TABLE campana_militar IS 'Información detallada sobre campañas y operaciones militares.';
COMMENT ON COLUMN campana_militar.Nombre_Oficial_Campana IS 'Nombre oficial de la campaña u operación militar.';
COMMENT ON COLUMN campana_militar.Nombre_Codigo_Operacion IS 'Nombre en clave de la operación (Ej: Operación Barbarroja, Día D).';
COMMENT ON COLUMN campana_militar.Descripcion_Campana IS 'Descripción general de los objetivos, desarrollo y participantes de la campaña.';
COMMENT ON COLUMN campana_militar.Fecha_Inicio_Campana IS 'Fecha de inicio de la campaña.';
COMMENT ON COLUMN campana_militar.Fecha_Fin_Campana IS 'Fecha de finalización de la campaña.';
COMMENT ON COLUMN campana_militar.Objetivo_Campana IS 'Objetivos estratégicos y tácticos principales de la campaña.';
COMMENT ON COLUMN campana_militar.Resultado_Campana IS 'Resultado o desenlace general de la campaña.';
COMMENT ON COLUMN campana_militar.Teatro_Operaciones IS 'Principal teatro de operaciones donde se desarrolló (Ej: Frente Oriental, Frente Occidental, Pacífico, Mediterráneo).';
COMMENT ON COLUMN campana_militar.Paises_Principales_Eje IS 'Listado de países principales del Eje involucrados.';
COMMENT ON COLUMN campana_militar.Paises_Principales_Aliados IS 'Listado de países principales de los Aliados involucrados.';

CREATE TABLE batalla (
  ID_Batalla                        NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Nombre_Batalla                    VARCHAR2(255 CHAR) NOT NULL,
  ID_Campana                        NUMBER(10),
  ID_Pais_Batalla                   NUMBER(10) NOT NULL,
  ID_Lugar_Batalla                  NUMBER(10),
  Lugar_Especifico_Texto            VARCHAR2(255 CHAR),
  Fecha_Inicio_Batalla              DATE NOT NULL,
  Fecha_Fin_Batalla                 DATE,
  Descripcion_Batalla               CLOB,
  Resultado_Batalla                 CLOB,
  Bajas_Estimadas_Eje               NUMBER(10),
  Bajas_Estimadas_Aliados           NUMBER(10),
  Unidades_Principales_Eje_Texto    CLOB,
  Unidades_Principales_Aliados_Texto CLOB,
  Importancia_Estrategica           CLOB,
  Fecha_Creacion                    TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion               TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_batalla PRIMARY KEY (ID_Batalla),
  CONSTRAINT fk_batalla_campana FOREIGN KEY (ID_Campana) REFERENCES campana_militar (ID_Campana) ON DELETE SET NULL, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_batalla_lugar FOREIGN KEY (ID_Lugar_Batalla) REFERENCES lugar (ID_Lugar) ON DELETE SET NULL, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_batalla_pais FOREIGN KEY (ID_Pais_Batalla) REFERENCES pais (ID_Pais) -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE batalla IS 'Información detallada de las batallas ocurridas.';
COMMENT ON COLUMN batalla.Nombre_Batalla IS 'Nombre comúnmente conocido de la batalla.';
COMMENT ON COLUMN batalla.ID_Campana IS 'Campaña militar a la que pertenece la batalla (FK a Campana_Militar.ID_Campana, opcional).';
COMMENT ON COLUMN batalla.ID_Pais_Batalla IS 'País donde se desarrolló principalmente la batalla (FK a Pais.ID_Pais).';
COMMENT ON COLUMN batalla.ID_Lugar_Batalla IS 'Lugar geográfico específico (ciudad, región) de la batalla (FK a Lugar.ID_Lugar).';
COMMENT ON COLUMN batalla.Lugar_Especifico_Texto IS 'Descripción textual adicional del lugar si no hay ID_Lugar o como complemento (Ej: "Cerca del río Volga").';
COMMENT ON COLUMN batalla.Fecha_Inicio_Batalla IS 'Fecha de inicio de la batalla.';
COMMENT ON COLUMN batalla.Fecha_Fin_Batalla IS 'Fecha de finalización de la batalla (nulo si fue un solo día o se desconoce el fin exacto).';
COMMENT ON COLUMN batalla.Descripcion_Batalla IS 'Breve descripción o resumen de los eventos principales de la batalla.';
COMMENT ON COLUMN batalla.Resultado_Batalla IS 'Resultado o desenlace de la batalla (Ej: Victoria Aliada, Victoria del Eje, Indeciso, Retirada Táctica).';
COMMENT ON COLUMN batalla.Bajas_Estimadas_Eje IS 'Número total estimado de bajas (muertos, heridos, capturados) del Eje.';
COMMENT ON COLUMN batalla.Bajas_Estimadas_Aliados IS 'Número total estimado de bajas (muertos, heridos, capturados) de los Aliados.';
COMMENT ON COLUMN batalla.Unidades_Principales_Eje_Texto IS 'Listado descriptivo de unidades principales del Eje involucradas.';
COMMENT ON COLUMN batalla.Unidades_Principales_Aliados_Texto IS 'Listado descriptivo de unidades principales de los Aliados involucradas.';
COMMENT ON COLUMN batalla.Importancia_Estrategica IS 'Notas sobre la importancia estratégica de la batalla.';

CREATE INDEX idx_batalla_nombre ON batalla (Nombre_Batalla);
CREATE INDEX idx_batalla_fechainicio ON batalla (Fecha_Inicio_Batalla);
CREATE INDEX idx_batalla_pais ON batalla (ID_Pais_Batalla);


CREATE TABLE soldado_medalla (
  ID_Soldado_Medalla             NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  ID_Soldado                     NUMBER(10) NOT NULL,
  ID_Medalla                     NUMBER(10) NOT NULL,
  Fecha_Obtencion_Medalla        DATE,
  Motivo_Condecoracion_Especifico CLOB,
  ID_Batalla_Relacionada_Medalla NUMBER(10),
  Documento_Referencia_Medalla   VARCHAR2(255 CHAR),
  Otorgada_Postumamente          NUMBER(1) DEFAULT 0 NOT NULL,
  Fecha_Creacion                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion            TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_soldado_medalla PRIMARY KEY (ID_Soldado_Medalla),
  CONSTRAINT uq_soldado_medalla_fecha UNIQUE (ID_Soldado, ID_Medalla, Fecha_Obtencion_Medalla),
  CONSTRAINT chk_soldado_med_otorg_post CHECK (Otorgada_Postumamente IN (0,1)),
  CONSTRAINT fk_soldmed_refsoldado FOREIGN KEY (ID_Soldado) REFERENCES soldado (ID_Soldado) ON DELETE CASCADE, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldmed_refmedalla FOREIGN KEY (ID_Medalla) REFERENCES medalla (ID_Medalla), -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldmed_refbatalla FOREIGN KEY (ID_Batalla_Relacionada_Medalla) REFERENCES batalla (ID_Batalla) ON DELETE SET NULL -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE soldado_medalla IS 'Registro de medallas y condecoraciones otorgadas a cada soldado.';
COMMENT ON COLUMN soldado_medalla.ID_Soldado IS 'Identificador del soldado (FK a Soldado.ID_Soldado).';
COMMENT ON COLUMN soldado_medalla.ID_Medalla IS 'Identificador de la medalla (FK a Medalla.ID_Medalla).';
COMMENT ON COLUMN soldado_medalla.Fecha_Obtencion_Medalla IS 'Fecha en que se otorgó la medalla al soldado.';
COMMENT ON COLUMN soldado_medalla.Motivo_Condecoracion_Especifico IS 'Motivo específico o hazaña particular por la cual se otorgó esta medalla a este soldado.';
COMMENT ON COLUMN soldado_medalla.ID_Batalla_Relacionada_Medalla IS 'Batalla en la que se ganó la medalla, si aplica (FK a Batalla.ID_Batalla).';
COMMENT ON COLUMN soldado_medalla.Documento_Referencia_Medalla IS 'Referencia a documento oficial que acredita la condecoración (Ej: Número de decreto, página de diario oficial).';


CREATE TABLE rango (
  ID_Rango                     NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Nombre_Rango                 VARCHAR2(100 CHAR) NOT NULL,
  Abreviatura_Rango            VARCHAR2(30 CHAR),
  Orden_Jerarquico             NUMBER(10) DEFAULT 0 NOT NULL,
  ID_Rama_Ejercito_Aplicable   NUMBER(10),
  Equivalencia_OTAN            VARCHAR2(10 CHAR),
  Fecha_Creacion               TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion          TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_rango PRIMARY KEY (ID_Rango),
  CONSTRAINT uq_rango_nombre_rama UNIQUE (Nombre_Rango, ID_Rama_Ejercito_Aplicable),
  CONSTRAINT fk_rango_ramaejercito FOREIGN KEY (ID_Rama_Ejercito_Aplicable) REFERENCES rama_ejercito (ID_Rama_Ejercito) ON DELETE SET NULL -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE rango IS 'Catálogo de rangos militares y su jerarquía.';
COMMENT ON COLUMN rango.Nombre_Rango IS 'Nombre del rango militar (Ej: Soldado, Sargento, Capitán, General).';
COMMENT ON COLUMN rango.Abreviatura_Rango IS 'Abreviatura común del rango (Ej: Sdo., Sgt., Cap., Gral.).';
COMMENT ON COLUMN rango.Orden_Jerarquico IS 'Valor numérico para facilitar el ordenamiento por jerarquía (mayor número = mayor rango).';
COMMENT ON COLUMN rango.ID_Rama_Ejercito_Aplicable IS 'Si el rango es específico o predominantemente usado en una rama del ejército (FK a Rama_Ejercito.ID_Rama_Ejercito).';
COMMENT ON COLUMN rango.Equivalencia_OTAN IS 'Código de rango equivalente OTAN (Ej: OR-1, OF-3), si aplica.';
CREATE TABLE soldado_ascenso (
  ID_Soldado_Ascenso            NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  ID_Soldado                    NUMBER(10) NOT NULL,
  ID_Rango                      NUMBER(10) NOT NULL,
  Fecha_Inicio_Rango            DATE NOT NULL,
  Fecha_Fin_Rango               DATE,
  Documento_Referencia_Ascenso  VARCHAR2(255 CHAR),
  Notas_Adicionales_Ascenso     CLOB,
  Fecha_Creacion                TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion           TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_soldado_ascenso PRIMARY KEY (ID_Soldado_Ascenso),
  CONSTRAINT uq_soldado_rango_fechainicio UNIQUE (ID_Soldado, ID_Rango, Fecha_Inicio_Rango),
  CONSTRAINT fk_soldasc_refsoldado FOREIGN KEY (ID_Soldado) REFERENCES soldado (ID_Soldado) ON DELETE CASCADE, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldasc_refrango FOREIGN KEY (ID_Rango) REFERENCES rango (ID_Rango) -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE soldado_ascenso IS 'Historial de ascensos y rangos ostentados por el soldado a lo largo de su servicio.';
COMMENT ON COLUMN soldado_ascenso.ID_Soldado IS 'Identificador del soldado (FK a Soldado.ID_Soldado).';
COMMENT ON COLUMN soldado_ascenso.ID_Rango IS 'Identificador del rango obtenido (FK a Rango.ID_Rango).';
COMMENT ON COLUMN soldado_ascenso.Fecha_Inicio_Rango IS 'Fecha en que el soldado obtuvo este rango.';
COMMENT ON COLUMN soldado_ascenso.Fecha_Fin_Rango IS 'Fecha en que el soldado dejó este rango. Nulo si es el rango activo hasta su muerte/fin de servicio.';
COMMENT ON COLUMN soldado_ascenso.Documento_Referencia_Ascenso IS 'Referencia a documento o decreto que oficializa el ascenso.';
COMMENT ON COLUMN soldado_ascenso.Notas_Adicionales_Ascenso IS 'Notas adicionales sobre el ascenso o las circunstancias del mismo.';


CREATE TABLE unidad_militar (
  ID_Unidad                     NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  Nombre_Unidad                 VARCHAR2(255 CHAR) NOT NULL,
  Tipo_Unidad                   VARCHAR2(50 CHAR) NOT NULL, -- Many enum values, use VARCHAR2 and CHECK
  ID_Pais_Afiliacion_Unidad     NUMBER(10),
  ID_Rama_Ejercito_Unidad       NUMBER(10),
  ID_Unidad_Superior_Directa    NUMBER(10),
  Fecha_Activacion_Unidad       DATE,
  Fecha_Desactivacion_Unidad    DATE,
  Insignia_Unidad_URL           VARCHAR2(2048 CHAR),
  Historia_Resumida_Unidad      CLOB,
  Lema_O_Grito_Unidad           VARCHAR2(255 CHAR),
  Especializacion_Unidad        VARCHAR2(150 CHAR),
  Fecha_Creacion                TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion           TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_unidad_militar PRIMARY KEY (ID_Unidad),
  CONSTRAINT uq_unidad_nombre_pais_tipo UNIQUE (Nombre_Unidad, ID_Pais_Afiliacion_Unidad, Tipo_Unidad),
  CONSTRAINT chk_unidad_tipo CHECK (Tipo_Unidad IN ('Grupo de Ejércitos','Ejército','Cuerpo de Ejército','División','Brigada','Regimiento','Batallón','Compañía','Batería','Pelotón','Escuadrón (Tierra)','Flota','Flotilla','Escuadrón (Naval)','Ala (Aérea)','Grupo (Aéreo)','Escuadrilla (Aérea)','Fuerza de Tarea','Destacamento','Otro')),
  CONSTRAINT fk_unidad_refpaisafil FOREIGN KEY (ID_Pais_Afiliacion_Unidad) REFERENCES pais (ID_Pais) ON DELETE SET NULL, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_unidad_reframaejer FOREIGN KEY (ID_Rama_Ejercito_Unidad) REFERENCES rama_ejercito (ID_Rama_Ejercito) ON DELETE SET NULL, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_unidad_refunidadsup FOREIGN KEY (ID_Unidad_Superior_Directa) REFERENCES unidad_militar (ID_Unidad) ON DELETE SET NULL -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE unidad_militar IS 'Catálogo de unidades militares, su tipo, afiliación y estructura jerárquica.';
COMMENT ON COLUMN unidad_militar.Nombre_Unidad IS 'Nombre oficial o designación de la unidad militar.';
COMMENT ON COLUMN unidad_militar.Tipo_Unidad IS 'Tipo o nivel orgánico de la unidad militar.';
COMMENT ON COLUMN unidad_militar.ID_Pais_Afiliacion_Unidad IS 'País al que pertenece o está afiliada la unidad militar (FK a Pais.ID_Pais).';
COMMENT ON COLUMN unidad_militar.ID_Rama_Ejercito_Unidad IS 'Rama del ejército a la que pertenece la unidad (FK a Rama_Ejercito.ID_Rama_Ejercito).';
COMMENT ON COLUMN unidad_militar.ID_Unidad_Superior_Directa IS 'Identificador de la unidad militar inmediatamente superior en la jerarquía (FK a Unidad_Militar.ID_Unidad).';
COMMENT ON COLUMN unidad_militar.Fecha_Activacion_Unidad IS 'Fecha de creación o activación de la unidad.';
COMMENT ON COLUMN unidad_militar.Fecha_Desactivacion_Unidad IS 'Fecha de disolución o desactivación de la unidad.';
COMMENT ON COLUMN unidad_militar.Insignia_Unidad_URL IS 'URL a una imagen de la insignia o emblema de la unidad.';
COMMENT ON COLUMN unidad_militar.Historia_Resumida_Unidad IS 'Breve historia, acciones notables o reseña de la unidad militar.';
COMMENT ON COLUMN unidad_militar.Lema_O_Grito_Unidad IS 'Lema, lema o grito de guerra característico de la unidad.';
COMMENT ON COLUMN unidad_militar.Especializacion_Unidad IS 'Ej: Infantería, Blindada, Artillería, Paracaidista, Logística.';

CREATE INDEX idx_unidad_nombre ON unidad_militar (Nombre_Unidad);
CREATE INDEX idx_unidad_tipo ON unidad_militar (Tipo_Unidad);
CREATE INDEX idx_unidad_paisafil ON unidad_militar (ID_Pais_Afiliacion_Unidad);


CREATE TABLE soldado_participacion_batalla (
  ID_Participacion_Batalla         NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  ID_Soldado                       NUMBER(10) NOT NULL,
  ID_Batalla                       NUMBER(10) NOT NULL,
  ID_Unidad_Militar_En_Batalla     NUMBER(10),
  Rol_O_Acciones_En_Batalla        VARCHAR2(255 CHAR),
  Estado_Soldado_Post_Batalla      VARCHAR2(50 CHAR), -- Ileso,Herido Leve,Herido Grave,Caído en Combate (KIA),Prisionero de Guerra (POW),Desaparecido en Acción (MIA),Evacuado por Heridas,Otro
  Fecha_Inicio_Participacion_Batalla DATE,
  Fecha_Fin_Participacion_Batalla  DATE,
  Notas_Participacion_Batalla      CLOB,
  Fecha_Creacion                   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion              TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_sold_part_batalla PRIMARY KEY (ID_Participacion_Batalla),
  CONSTRAINT uq_sold_bat_partunica UNIQUE (ID_Soldado, ID_Batalla),
  CONSTRAINT chk_sold_part_bat_estado CHECK (Estado_Soldado_Post_Batalla IN ('Ileso','Herido Leve','Herido Grave','Caído en Combate (KIA)','Prisionero de Guerra (POW)','Desaparecido en Acción (MIA)','Evacuado por Heridas','Otro')),
  CONSTRAINT fk_soldpartbat_refsoldado FOREIGN KEY (ID_Soldado) REFERENCES soldado (ID_Soldado) ON DELETE CASCADE, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldpartbat_refbatalla FOREIGN KEY (ID_Batalla) REFERENCES batalla (ID_Batalla), -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldpartbat_refunidad FOREIGN KEY (ID_Unidad_Militar_En_Batalla) REFERENCES unidad_militar (ID_Unidad) ON DELETE SET NULL -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE soldado_participacion_batalla IS 'Registro de la participación de los soldados en batallas específicas, incluyendo su unidad y estado.';
COMMENT ON COLUMN soldado_participacion_batalla.ID_Soldado IS 'Identificador del soldado participante (FK a Soldado.ID_Soldado).';
COMMENT ON COLUMN soldado_participacion_batalla.ID_Batalla IS 'Identificador de la batalla en la que participó (FK a Batalla.ID_Batalla).';
COMMENT ON COLUMN soldado_participacion_batalla.ID_Unidad_Militar_En_Batalla IS 'Unidad a la que pertenecía el soldado durante esta batalla específica (FK a Unidad_Militar.ID_Unidad).';
COMMENT ON COLUMN soldado_participacion_batalla.Rol_O_Acciones_En_Batalla IS 'Descripción del rol o acciones destacadas del soldado en la batalla.';
COMMENT ON COLUMN soldado_participacion_batalla.Estado_Soldado_Post_Batalla IS 'Estado del soldado al finalizar su participación en la batalla.';
COMMENT ON COLUMN soldado_participacion_batalla.Fecha_Inicio_Participacion_Batalla IS 'Fecha de inicio de participación del soldado en la batalla (si difiere del inicio general de la batalla).';
COMMENT ON COLUMN soldado_participacion_batalla.Fecha_Fin_Participacion_Batalla IS 'Fecha de fin de participación del soldado en la batalla (si difiere del fin general de la batalla).';


CREATE TABLE soldado_pertenencia_unidad (
  ID_Pertenencia                   NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  ID_Soldado                       NUMBER(10) NOT NULL,
  ID_Unidad                        NUMBER(10) NOT NULL,
  Fecha_Inicio_Pertenencia_Unidad  DATE NOT NULL,
  Fecha_Fin_Pertenencia_Unidad     DATE,
  Rol_Desempenado_En_Unidad        VARCHAR2(100 CHAR),
  Notas_Sobre_Pertenencia          CLOB,
  Fecha_Creacion                   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion              TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_sold_pert_unidad PRIMARY KEY (ID_Pertenencia),
  CONSTRAINT uq_sold_unidad_fechainiciop UNIQUE (ID_Soldado, ID_Unidad, Fecha_Inicio_Pertenencia_Unidad),
  CONSTRAINT fk_soldpert_refsoldado FOREIGN KEY (ID_Soldado) REFERENCES soldado (ID_Soldado) ON DELETE CASCADE, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_soldpert_refunidad FOREIGN KEY (ID_Unidad) REFERENCES unidad_militar (ID_Unidad) -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE soldado_pertenencia_unidad IS 'Registro de las unidades a las que perteneció un soldado y los periodos correspondientes.';
COMMENT ON COLUMN soldado_pertenencia_unidad.ID_Soldado IS 'Identificador del soldado (FK a Soldado.ID_Soldado).';
COMMENT ON COLUMN soldado_pertenencia_unidad.ID_Unidad IS 'Identificador de la unidad militar a la que perteneció (FK a Unidad_Militar.ID_Unidad).';
COMMENT ON COLUMN soldado_pertenencia_unidad.Fecha_Inicio_Pertenencia_Unidad IS 'Fecha en que el soldado se unió o fue asignado a esta unidad.';
COMMENT ON COLUMN soldado_pertenencia_unidad.Fecha_Fin_Pertenencia_Unidad IS 'Fecha en que el soldado dejó la unidad (nulo si perteneció hasta su muerte/fin de servicio en la unidad).';
COMMENT ON COLUMN soldado_pertenencia_unidad.Rol_Desempenado_En_Unidad IS 'Rol o cargo desempeñado por el soldado en la unidad (Ej: Fusilero, Jefe de Pelotón, Operador de Radio).';
COMMENT ON COLUMN soldado_pertenencia_unidad.Notas_Sobre_Pertenencia IS 'Notas adicionales sobre la pertenencia del soldado a esta unidad (Ej: Transferido, Herido en servicio con esta unidad).';


CREATE TABLE unidad_militar_comandante (
  ID_Comandancia                      NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  ID_Unidad_Comandada                 NUMBER(10) NOT NULL,
  ID_Soldado_Comandante               NUMBER(10) NOT NULL,
  ID_Rango_Comandante_Al_Asumir_Mando NUMBER(10),
  Fecha_Inicio_Comando_Unidad         DATE NOT NULL,
  Fecha_Fin_Comando_Unidad            DATE,
  Tipo_Liderazgo_Comando              VARCHAR2(100 CHAR),
  Notas_Sobre_Comando                 CLOB,
  Fecha_Creacion                      TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_unidad_mil_cmd PRIMARY KEY (ID_Comandancia),
  CONSTRAINT uq_unidad_cmd_fechainicioc UNIQUE (ID_Unidad_Comandada, ID_Soldado_Comandante, Fecha_Inicio_Comando_Unidad),
  CONSTRAINT fk_unidadcmd_refunidad FOREIGN KEY (ID_Unidad_Comandada) REFERENCES unidad_militar (ID_Unidad) ON DELETE CASCADE, -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_unidadcmd_refsoldado FOREIGN KEY (ID_Soldado_Comandante) REFERENCES soldado (ID_Soldado), -- ON UPDATE CASCADE not supported
  CONSTRAINT fk_unidadcmd_refrango FOREIGN KEY (ID_Rango_Comandante_Al_Asumir_Mando) REFERENCES rango (ID_Rango) ON DELETE SET NULL -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE unidad_militar_comandante IS 'Registra los comandantes de las unidades militares y los periodos de su comando.';
COMMENT ON COLUMN unidad_militar_comandante.ID_Unidad_Comandada IS 'Identificador de la unidad militar comandada (FK a Unidad_Militar.ID_Unidad).';
COMMENT ON COLUMN unidad_militar_comandante.ID_Soldado_Comandante IS 'Identificador del soldado que ejerció como comandante (FK a Soldado.ID_Soldado).';
COMMENT ON COLUMN unidad_militar_comandante.ID_Rango_Comandante_Al_Asumir_Mando IS 'Rango del comandante al momento de asumir esta posición específica (FK a Rango.ID_Rango).';
COMMENT ON COLUMN unidad_militar_comandante.Fecha_Inicio_Comando_Unidad IS 'Fecha en que el soldado asumió el comando de la unidad.';
COMMENT ON COLUMN unidad_militar_comandante.Fecha_Fin_Comando_Unidad IS 'Fecha en que el soldado dejó el comando (nulo si comandó hasta disolución de unidad, su muerte o relevo).';
COMMENT ON COLUMN unidad_militar_comandante.Tipo_Liderazgo_Comando IS 'Tipo de comando (Ej: Interino, Oficial al Mando, Designado, En Funciones).';
COMMENT ON COLUMN unidad_militar_comandante.Notas_Sobre_Comando IS 'Notas adicionales sobre el periodo de comando.';


CREATE TABLE usuario_sistema (
  Correo_Electronico                 VARCHAR2(255 CHAR) NOT NULL,
  Nombres_Usuario                    VARCHAR2(150 CHAR) NOT NULL,
  Apellidos_Usuario                  VARCHAR2(150 CHAR) NOT NULL,
  ID_Pais_Origen_Usuario             NUMBER(10) NOT NULL,
  Password_Hash_Usuario              VARCHAR2(255 CHAR) NOT NULL,
  Rol_Usuario_Sistema                VARCHAR2(50 CHAR) DEFAULT 'Consultor Registrado' NOT NULL, -- Various roles
  Fecha_Registro_Usuario             TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  Fecha_Ultimo_Acceso_Usuario        TIMESTAMP,
  Estado_Cuenta_Usuario              VARCHAR2(30 CHAR) DEFAULT 'Pendiente Verificacion Email' NOT NULL, -- Various states
  Token_Verificacion_Email           VARCHAR2(100 CHAR),
  Fecha_Expiracion_Token_Verificacion TIMESTAMP,
  Token_Reseteo_Password             VARCHAR2(100 CHAR),
  Fecha_Expiracion_Token_Reseteo     TIMESTAMP,
  Numero_Intentos_Fallidos_Login     NUMBER(3) DEFAULT 0 NOT NULL,
  Fecha_Ultimo_Intento_Fallido       TIMESTAMP,
  Fecha_Ultimo_Cambio_Password       TIMESTAMP,
  Preferencias_Usuario               CLOB,
  Fecha_Creacion                     TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL,
  Fecha_Actualizacion                TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL, -- Trigger needed for ON UPDATE
  CONSTRAINT pk_usuario_sistema PRIMARY KEY (Correo_Electronico),
  CONSTRAINT uq_usuario_token_verif UNIQUE (Token_Verificacion_Email),
  CONSTRAINT uq_usuario_token_reset UNIQUE (Token_Reseteo_Password),
  CONSTRAINT chk_usuario_rol CHECK (Rol_Usuario_Sistema IN ('Administrador Global','Administrador Contenido','Investigador Senior','Colaborador Verificado','Consultor Registrado','Consultor Anónimo')),
  CONSTRAINT chk_usuario_estado_cuenta CHECK (Estado_Cuenta_Usuario IN ('Activo','Inactivo','Suspendido','Pendiente Verificacion Email','Bloqueado')),
  CONSTRAINT chk_usuario_pref_json CHECK (Preferencias_Usuario IS NULL OR Preferencias_Usuario IS JSON),
  CONSTRAINT fk_usuariosist_refpaisorig FOREIGN KEY (ID_Pais_Origen_Usuario) REFERENCES pais (ID_Pais) -- ON UPDATE CASCADE not supported
);
COMMENT ON TABLE usuario_sistema IS 'Usuarios registrados para acceder, consultar y/o contribuir al sistema de memoria histórica.';
COMMENT ON COLUMN usuario_sistema.Correo_Electronico IS 'Correo electrónico del usuario, usado como identificador único y para login.';
COMMENT ON COLUMN usuario_sistema.ID_Pais_Origen_Usuario IS 'País de origen del usuario (FK a Pais.ID_Pais).';
COMMENT ON COLUMN usuario_sistema.Password_Hash_Usuario IS 'Hash de la contraseña del usuario (NUNCA almacenar contraseñas en texto plano). Se recomienda Argon2 o bcrypt.';
COMMENT ON COLUMN usuario_sistema.Rol_Usuario_Sistema IS 'Rol del usuario en el sistema, define niveles de acceso y permisos.';
COMMENT ON COLUMN usuario_sistema.Fecha_Registro_Usuario IS 'Fecha y hora en que se registró el usuario.';
COMMENT ON COLUMN usuario_sistema.Fecha_Ultimo_Acceso_Usuario IS 'Fecha y hora del último acceso del usuario al sistema.';
COMMENT ON COLUMN usuario_sistema.Estado_Cuenta_Usuario IS 'Estado actual de la cuenta del usuario.';
COMMENT ON COLUMN usuario_sistema.Token_Verificacion_Email IS 'Token único para verificación de correo electrónico tras el registro.';
COMMENT ON COLUMN usuario_sistema.Fecha_Expiracion_Token_Verificacion IS 'Fecha de expiración del token de verificación de email.';
COMMENT ON COLUMN usuario_sistema.Token_Reseteo_Password IS 'Token único para el proceso de reseteo de contraseña.';
COMMENT ON COLUMN usuario_sistema.Fecha_Expiracion_Token_Reseteo IS 'Fecha de expiración del token de reseteo de contraseña.';
COMMENT ON COLUMN usuario_sistema.Preferencias_Usuario IS 'Preferencias del usuario en formato JSON (Ej: idioma, notificaciones).';

-- FK for auditoria_cambios needs usuario_sistema to be created first
ALTER TABLE auditoria_cambios ADD CONSTRAINT fk_auditacamb_refusuariosist FOREIGN KEY (Correo_Usuario_Responsable) REFERENCES usuario_sistema (Correo_Electronico) ON DELETE SET NULL; -- ON UPDATE CASCADE not supported

-- Triggers para simular ON UPDATE CURRENT_TIMESTAMP
CREATE OR REPLACE TRIGGER trg_pais_bu
BEFORE UPDATE ON pais
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_lugar_bu
BEFORE UPDATE ON lugar
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_causa_muerte_bu
BEFORE UPDATE ON causa_muerte
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_rama_ejercito_bu
BEFORE UPDATE ON rama_ejercito
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_soldado_bu
BEFORE UPDATE ON soldado
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_inf_muerte_trans_bu
BEFORE UPDATE ON informacion_muerte_transporte
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_lugar_inhumacion_bu
BEFORE UPDATE ON lugar_inhumacion
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_medalla_bu
BEFORE UPDATE ON medalla
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_campana_militar_bu
BEFORE UPDATE ON campana_militar
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_batalla_bu_ts
BEFORE UPDATE ON batalla
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_soldado_medalla_bu
BEFORE UPDATE ON soldado_medalla
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_rango_bu
BEFORE UPDATE ON rango
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_soldado_ascenso_bu_ts
BEFORE UPDATE ON soldado_ascenso
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_unidad_militar_bu_ts
BEFORE UPDATE ON unidad_militar
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_sold_part_bat_bu
BEFORE UPDATE ON soldado_participacion_batalla
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_sold_pert_unidad_bu_ts
BEFORE UPDATE ON soldado_pertenencia_unidad
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_unidad_mil_cmd_bu_ts
BEFORE UPDATE ON unidad_militar_comandante
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER trg_usuario_sistema_bu
BEFORE UPDATE ON usuario_sistema
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP;
END;
/

-- TRIGGERS DE LÓGICA DE NEGOCIO

CREATE OR REPLACE TRIGGER TRG_Batalla_Fechas_BI
BEFORE INSERT ON batalla
FOR EACH ROW
DECLARE
  v_campana_inicio DATE;
  v_campana_fin DATE;
BEGIN
  IF :NEW.Fecha_Fin_Batalla IS NOT NULL AND :NEW.Fecha_Fin_Batalla < :NEW.Fecha_Inicio_Batalla THEN
    RAISE_APPLICATION_ERROR(-20001, 'Error [Batalla BI]: La fecha de fin de la batalla no puede ser anterior a su fecha de inicio.');
  END IF;

  IF :NEW.ID_Campana IS NOT NULL THEN
    SELECT Fecha_Inicio_Campana, Fecha_Fin_Campana INTO v_campana_inicio, v_campana_fin FROM Campana_Militar WHERE ID_Campana = :NEW.ID_Campana;
    IF v_campana_inicio IS NOT NULL AND :NEW.Fecha_Inicio_Batalla < v_campana_inicio THEN
      RAISE_APPLICATION_ERROR(-20002, 'Error [Batalla BI]: La fecha de inicio de la batalla no puede ser anterior al inicio de la campaña asociada.');
    END IF;
    IF v_campana_fin IS NOT NULL THEN
      IF :NEW.Fecha_Fin_Batalla IS NOT NULL AND :NEW.Fecha_Fin_Batalla > v_campana_fin THEN
        RAISE_APPLICATION_ERROR(-20003, 'Error [Batalla BI]: La fecha de fin de la batalla no puede ser posterior al fin de la campaña asociada.');
      END IF;
      IF :NEW.Fecha_Inicio_Batalla > v_campana_fin THEN
        RAISE_APPLICATION_ERROR(-20004, 'Error [Batalla BI]: La fecha de inicio de la batalla no puede ser posterior al fin de la campaña asociada.');
      END IF;
    END IF;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Batalla_Fechas_BU
BEFORE UPDATE ON batalla
FOR EACH ROW
DECLARE
  v_campana_inicio DATE;
  v_campana_fin DATE;
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP; -- Ensure this line from the other trigger is also present or merge triggers
  IF :NEW.Fecha_Fin_Batalla IS NOT NULL AND :NEW.Fecha_Fin_Batalla < :NEW.Fecha_Inicio_Batalla THEN
    RAISE_APPLICATION_ERROR(-20005, 'Error [Batalla BU]: La fecha de fin de la batalla no puede ser anterior a su fecha de inicio.');
  END IF;

  IF :NEW.ID_Campana IS NOT NULL THEN
    SELECT Fecha_Inicio_Campana, Fecha_Fin_Campana INTO v_campana_inicio, v_campana_fin FROM Campana_Militar WHERE ID_Campana = :NEW.ID_Campana;
    IF v_campana_inicio IS NOT NULL AND :NEW.Fecha_Inicio_Batalla < v_campana_inicio THEN
      RAISE_APPLICATION_ERROR(-20006, 'Error [Batalla BU]: La fecha de inicio de la batalla no puede ser anterior al inicio de la campaña asociada.');
    END IF;
    IF v_campana_fin IS NOT NULL THEN
      IF :NEW.Fecha_Fin_Batalla IS NOT NULL AND :NEW.Fecha_Fin_Batalla > v_campana_fin THEN
        RAISE_APPLICATION_ERROR(-20007, 'Error [Batalla BU]: La fecha de fin de la batalla no puede ser posterior al fin de la campaña asociada.');
      END IF;
      IF :NEW.Fecha_Inicio_Batalla > v_campana_fin THEN
        RAISE_APPLICATION_ERROR(-20008, 'Error [Batalla BU]: La fecha de inicio de la batalla no puede ser posterior al fin de la campaña asociada.');
      END IF;
    END IF;
  END IF;
END;
/


CREATE OR REPLACE TRIGGER TRG_Lugar_Inhumacion_Desc_BI
BEFORE INSERT ON lugar_inhumacion
FOR EACH ROW
BEGIN
  IF :NEW.Es_Inhumacion_Desconocida_Confirmado = 1 THEN -- Assuming 1 for TRUE
    :NEW.ID_Pais_Inhumacion := NULL;
    :NEW.ID_Lugar_Inhumacion_Detallado := NULL;
    :NEW.Lugar_Detallado_Texto_Inhumacion := NULL;
    :NEW.Nombre_Cementerio_Memorial := 'Desconocido';
    :NEW.Ubicacion_Exacta_Tumba := NULL;
    :NEW.Coordenadas_Sitio_Lat := NULL;
    :NEW.Coordenadas_Sitio_Lon := NULL;
    :NEW.Tipo_Sitio_Inhumacion := 'Desconocido';
    IF :NEW.Anotacion_Lugar_Desconocido IS NULL OR TRIM(:NEW.Anotacion_Lugar_Desconocido) = '' THEN
      :NEW.Anotacion_Lugar_Desconocido := 'Lugar exacto de inhumación desconocido o no confirmado. Se referencia información del lugar de muerte si está disponible en la ficha del soldado.';
    END IF;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Lugar_Inhumacion_Desc_BU
BEFORE UPDATE ON lugar_inhumacion
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP; -- Ensure this line from the other trigger is also present or merge triggers
  IF :NEW.Es_Inhumacion_Desconocida_Confirmado = 1 THEN
    :NEW.ID_Pais_Inhumacion := NULL;
    :NEW.ID_Lugar_Inhumacion_Detallado := NULL;
    :NEW.Lugar_Detallado_Texto_Inhumacion := NULL;
    :NEW.Nombre_Cementerio_Memorial := CASE WHEN :OLD.Nombre_Cementerio_Memorial IS NOT NULL AND :OLD.Es_Inhumacion_Desconocida_Confirmado = 0 THEN :OLD.Nombre_Cementerio_Memorial ELSE 'Desconocido' END;
    :NEW.Ubicacion_Exacta_Tumba := NULL;
    :NEW.Coordenadas_Sitio_Lat := NULL;
    :NEW.Coordenadas_Sitio_Lon := NULL;
    :NEW.Tipo_Sitio_Inhumacion := 'Desconocido';
    IF (:NEW.Anotacion_Lugar_Desconocido IS NULL OR TRIM(:NEW.Anotacion_Lugar_Desconocido) = '') AND
       (:OLD.Anotacion_Lugar_Desconocido IS NULL OR TRIM(:OLD.Anotacion_Lugar_Desconocido) = '' OR :OLD.Anotacion_Lugar_Desconocido != 'Lugar exacto de inhumación desconocido o no confirmado. Se referencia información del lugar de muerte si está disponible en la ficha del soldado.') THEN
      :NEW.Anotacion_Lugar_Desconocido := 'Lugar exacto de inhumación desconocido o no confirmado. Se referencia información del lugar de muerte si está disponible en la ficha del soldado.';
    END IF;
  ELSIF :OLD.Es_Inhumacion_Desconocida_Confirmado = 1 AND :NEW.Es_Inhumacion_Desconocida_Confirmado = 0 THEN
    IF :NEW.Anotacion_Lugar_Desconocido = 'Lugar exacto de inhumación desconocido o no confirmado. Se referencia información del lugar de muerte si está disponible en la ficha del soldado.' THEN
      :NEW.Anotacion_Lugar_Desconocido := NULL;
    END IF;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Soldado_Validacion_Fechas_BI
BEFORE INSERT ON soldado
FOR EACH ROW
BEGIN
  IF :NEW.Fecha_Muerte IS NOT NULL AND :NEW.Fecha_Nacimiento IS NOT NULL AND :NEW.Fecha_Muerte < :NEW.Fecha_Nacimiento THEN
    RAISE_APPLICATION_ERROR(-20009, 'Error [Soldado BI]: La fecha de muerte no puede ser anterior a la fecha de nacimiento.');
  END IF;
  IF :NEW.Fecha_Nacimiento > TRUNC(SYSDATE) THEN -- CURDATE() is TRUNC(SYSDATE)
    RAISE_APPLICATION_ERROR(-20010, 'Error [Soldado BI]: La fecha de nacimiento no puede ser en el futuro.');
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Auditoria_Soldado_AI
AFTER INSERT ON soldado
FOR EACH ROW
DECLARE
  v_current_user_email VARCHAR2(255 CHAR);
BEGIN
  -- Attempt to get a meaningful user, adapt as needed for your application context
  BEGIN
    SELECT SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER') INTO v_current_user_email FROM DUAL;
    IF v_current_user_email IS NULL THEN
        v_current_user_email := USER;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
        v_current_user_email := USER;
  END;

  INSERT INTO Auditoria_Cambios (Nombre_Tabla_Afectada, ID_Registro_Afectado_PK1, Correo_Usuario_Responsable, Tipo_Operacion_Realizada, Valores_Nuevos_Registro, Descripcion_Adicional_Cambio)
  VALUES ('Soldado', TO_CHAR(:NEW.ID_Soldado), v_current_user_email, 'INSERT',
          JSON_OBJECT('ID_Soldado' VALUE :NEW.ID_Soldado,
                      'Nombre_Completo_Busqueda' VALUE :NEW.Nombre_Completo_Busqueda,
                      'Fecha_Nacimiento' VALUE TO_CHAR(:NEW.Fecha_Nacimiento, 'YYYY-MM-DD'),
                      'ID_Pais_Origen' VALUE :NEW.ID_Pais_Origen),
          'Nuevo soldado registrado: ' || :NEW.Nombre_Completo_Busqueda);
END;
/

CREATE OR REPLACE TRIGGER TRG_Soldado_Validacion_Fechas_BU
BEFORE UPDATE ON soldado
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP; -- Ensure this line from the other trigger is also present or merge triggers
  IF :NEW.Fecha_Muerte IS NOT NULL AND :NEW.Fecha_Nacimiento IS NOT NULL AND :NEW.Fecha_Muerte < :NEW.Fecha_Nacimiento THEN
    RAISE_APPLICATION_ERROR(-20011, 'Error [Soldado BU]: La fecha de muerte no puede ser anterior a la fecha de nacimiento.');
  END IF;
  IF :NEW.Fecha_Nacimiento > TRUNC(SYSDATE) THEN
    RAISE_APPLICATION_ERROR(-20012, 'Error [Soldado BU]: La fecha de nacimiento no puede ser en el futuro.');
  END IF;
  IF :NEW.Fecha_Muerte IS NOT NULL AND :NEW.Fecha_Muerte > TRUNC(SYSDATE) THEN
    RAISE_APPLICATION_ERROR(-20013, 'Error [Soldado BU]: La fecha de muerte no puede ser en el futuro.');
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Auditoria_Soldado_AU
AFTER UPDATE ON soldado
FOR EACH ROW
DECLARE
  v_current_user_email VARCHAR2(255 CHAR);
BEGIN
  BEGIN
    SELECT SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER') INTO v_current_user_email FROM DUAL;
    IF v_current_user_email IS NULL THEN
        v_current_user_email := USER;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
        v_current_user_email := USER;
  END;

  IF :OLD.Nombres != :NEW.Nombres OR :OLD.Apellidos != :NEW.Apellidos OR :OLD.Fecha_Nacimiento != :NEW.Fecha_Nacimiento
     OR (:OLD.Fecha_Muerte IS NOT NULL AND :NEW.Fecha_Muerte IS NULL) OR (:OLD.Fecha_Muerte IS NULL AND :NEW.Fecha_Muerte IS NOT NULL) OR (:OLD.Fecha_Muerte != :NEW.Fecha_Muerte)
     OR (:OLD.ID_Causa_Muerte IS NOT NULL AND :NEW.ID_Causa_Muerte IS NULL) OR (:OLD.ID_Causa_Muerte IS NULL AND :NEW.ID_Causa_Muerte IS NOT NULL) OR (:OLD.ID_Causa_Muerte != :NEW.ID_Causa_Muerte)
  THEN
    INSERT INTO Auditoria_Cambios (Nombre_Tabla_Afectada, ID_Registro_Afectado_PK1, Correo_Usuario_Responsable, Tipo_Operacion_Realizada, Valores_Originales_Registro, Valores_Nuevos_Registro, Descripcion_Adicional_Cambio)
    VALUES ('Soldado', TO_CHAR(:OLD.ID_Soldado), v_current_user_email, 'UPDATE',
            JSON_OBJECT('Nombres' VALUE :OLD.Nombres, 'Apellidos' VALUE :OLD.Apellidos, 'Fecha_Nacimiento' VALUE TO_CHAR(:OLD.Fecha_Nacimiento, 'YYYY-MM-DD'), 'Fecha_Muerte' VALUE TO_CHAR(:OLD.Fecha_Muerte, 'YYYY-MM-DD'), 'ID_Causa_Muerte' VALUE :OLD.ID_Causa_Muerte),
            JSON_OBJECT('Nombres' VALUE :NEW.Nombres, 'Apellidos' VALUE :NEW.Apellidos, 'Fecha_Nacimiento' VALUE TO_CHAR(:NEW.Fecha_Nacimiento, 'YYYY-MM-DD'), 'Fecha_Muerte' VALUE TO_CHAR(:NEW.Fecha_Muerte, 'YYYY-MM-DD'), 'ID_Causa_Muerte' VALUE :NEW.ID_Causa_Muerte),
            'Actualización datos soldado: ' || :NEW.Nombre_Completo_Busqueda);
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Auditoria_Soldado_AD
AFTER DELETE ON soldado
FOR EACH ROW
DECLARE
  v_current_user_email VARCHAR2(255 CHAR);
BEGIN
  BEGIN
    SELECT SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER') INTO v_current_user_email FROM DUAL;
    IF v_current_user_email IS NULL THEN
        v_current_user_email := USER;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
        v_current_user_email := USER;
  END;

  INSERT INTO Auditoria_Cambios (Nombre_Tabla_Afectada, ID_Registro_Afectado_PK1, Correo_Usuario_Responsable, Tipo_Operacion_Realizada, Valores_Originales_Registro, Descripcion_Adicional_Cambio)
  VALUES ('Soldado', TO_CHAR(:OLD.ID_Soldado), v_current_user_email, 'DELETE',
          JSON_OBJECT('ID_Soldado' VALUE :OLD.ID_Soldado, 'Nombre_Completo_Busqueda' VALUE :OLD.Nombre_Completo_Busqueda, 'Fecha_Nacimiento' VALUE TO_CHAR(:OLD.Fecha_Nacimiento, 'YYYY-MM-DD')),
          'Soldado eliminado: ' || :OLD.Nombre_Completo_Busqueda);
END;
/

CREATE OR REPLACE TRIGGER TRG_Gestion_Periodo_Ascenso_BI
BEFORE INSERT ON soldado_ascenso
FOR EACH ROW
DECLARE
  v_fecha_nacimiento DATE;
  v_fecha_muerte DATE;
BEGIN
  SELECT Fecha_Nacimiento, Fecha_Muerte INTO v_fecha_nacimiento, v_fecha_muerte FROM Soldado WHERE ID_Soldado = :NEW.ID_Soldado;

  IF :NEW.Fecha_Inicio_Rango < v_fecha_nacimiento THEN
    RAISE_APPLICATION_ERROR(-20014, 'Error [Ascenso BI]: La fecha de inicio del rango no puede ser anterior a la fecha de nacimiento del soldado.');
  END IF;
  IF v_fecha_muerte IS NOT NULL AND :NEW.Fecha_Inicio_Rango > v_fecha_muerte THEN
    RAISE_APPLICATION_ERROR(-20015, 'Error [Ascenso BI]: La fecha de inicio del rango no puede ser posterior a la fecha de muerte del soldado.');
  END IF;
  IF :NEW.Fecha_Fin_Rango IS NOT NULL THEN
    IF :NEW.Fecha_Fin_Rango < :NEW.Fecha_Inicio_Rango THEN
      RAISE_APPLICATION_ERROR(-20016, 'Error [Ascenso BI]: La fecha de fin de rango no puede ser anterior a la fecha de inicio del rango.');
    END IF;
    IF v_fecha_muerte IS NOT NULL AND :NEW.Fecha_Fin_Rango > v_fecha_muerte THEN
      :NEW.Fecha_Fin_Rango := v_fecha_muerte;
    END IF;
  END IF;

  IF :NEW.Fecha_Fin_Rango IS NULL THEN
    UPDATE Soldado_Ascenso
    SET Fecha_Fin_Rango = :NEW.Fecha_Inicio_Rango - 1 -- Subtract 1 day
    WHERE ID_Soldado = :NEW.ID_Soldado
      AND Fecha_Fin_Rango IS NULL
      AND ID_Rango != :NEW.ID_Rango
      AND Fecha_Inicio_Rango < :NEW.Fecha_Inicio_Rango;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Gestion_Periodo_Ascenso_BU
BEFORE UPDATE ON soldado_ascenso
FOR EACH ROW
DECLARE
  v_fecha_nacimiento DATE;
  v_fecha_muerte DATE;
  v_count NUMBER;
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP; -- Ensure this line from the other trigger is also present or merge triggers
  SELECT Fecha_Nacimiento, Fecha_Muerte INTO v_fecha_nacimiento, v_fecha_muerte FROM Soldado WHERE ID_Soldado = :NEW.ID_Soldado;

  IF :NEW.Fecha_Inicio_Rango < v_fecha_nacimiento THEN
    RAISE_APPLICATION_ERROR(-20017, 'Error [Ascenso BU]: La fecha de inicio del rango no puede ser anterior a la fecha de nacimiento.');
  END IF;
  IF v_fecha_muerte IS NOT NULL AND :NEW.Fecha_Inicio_Rango > v_fecha_muerte THEN
    RAISE_APPLICATION_ERROR(-20018, 'Error [Ascenso BU]: La fecha de inicio del rango no puede ser posterior a la fecha de muerte.');
  END IF;
  IF :NEW.Fecha_Fin_Rango IS NOT NULL THEN
    IF :NEW.Fecha_Fin_Rango < :NEW.Fecha_Inicio_Rango THEN
      RAISE_APPLICATION_ERROR(-20019, 'Error [Ascenso BU]: La fecha de fin de rango no puede ser anterior a la fecha de inicio.');
    END IF;
    IF v_fecha_muerte IS NOT NULL AND :NEW.Fecha_Fin_Rango > v_fecha_muerte THEN
      :NEW.Fecha_Fin_Rango := v_fecha_muerte;
    END IF;
  END IF;

  IF :NEW.Fecha_Fin_Rango IS NULL AND :OLD.Fecha_Fin_Rango IS NOT NULL THEN
    UPDATE Soldado_Ascenso
    SET Fecha_Fin_Rango = :NEW.Fecha_Inicio_Rango - 1
    WHERE ID_Soldado = :NEW.ID_Soldado
      AND Fecha_Fin_Rango IS NULL
      AND ID_Soldado_Ascenso != :NEW.ID_Soldado_Ascenso
      AND Fecha_Inicio_Rango < :NEW.Fecha_Inicio_Rango;
  END IF;

  SELECT COUNT(*) INTO v_count FROM Soldado_Ascenso
  WHERE ID_Soldado = :NEW.ID_Soldado
    AND ID_Soldado_Ascenso != :NEW.ID_Soldado_Ascenso
    AND :NEW.Fecha_Inicio_Rango < COALESCE(Fecha_Fin_Rango, TO_DATE('9999-12-31','YYYY-MM-DD'))
    AND COALESCE(:NEW.Fecha_Fin_Rango, TO_DATE('9999-12-31','YYYY-MM-DD')) > Fecha_Inicio_Rango;
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20020, 'Error [Ascenso BU]: El periodo del rango se solapa con otro rango existente para este soldado.');
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Gest_Periodo_Perten_Unid_BI
BEFORE INSERT ON soldado_pertenencia_unidad
FOR EACH ROW
DECLARE
  v_fecha_nacimiento DATE;
  v_fecha_muerte DATE;
  v_unidad_creacion DATE;
  v_unidad_disolucion DATE;
BEGIN
  SELECT Fecha_Nacimiento, Fecha_Muerte INTO v_fecha_nacimiento, v_fecha_muerte FROM Soldado WHERE ID_Soldado = :NEW.ID_Soldado;
  SELECT Fecha_Activacion_Unidad, Fecha_Desactivacion_Unidad INTO v_unidad_creacion, v_unidad_disolucion FROM Unidad_Militar WHERE ID_Unidad = :NEW.ID_Unidad;

  IF :NEW.Fecha_Inicio_Pertenencia_Unidad < v_fecha_nacimiento THEN
    RAISE_APPLICATION_ERROR(-20021, 'Error [Pertenencia BI]: Fecha de inicio de pertenencia no puede ser anterior al nacimiento del soldado.');
  END IF;
  IF v_fecha_muerte IS NOT NULL AND :NEW.Fecha_Inicio_Pertenencia_Unidad > v_fecha_muerte THEN
    RAISE_APPLICATION_ERROR(-20022, 'Error [Pertenencia BI]: Fecha de inicio de pertenencia no puede ser posterior a la muerte del soldado.');
  END IF;
  IF v_unidad_creacion IS NOT NULL AND :NEW.Fecha_Inicio_Pertenencia_Unidad < v_unidad_creacion THEN
    RAISE_APPLICATION_ERROR(-20023, 'Error [Pertenencia BI]: Fecha de inicio de pertenencia no puede ser anterior a la activación de la unidad.');
  END IF;

  IF :NEW.Fecha_Fin_Pertenencia_Unidad IS NOT NULL THEN
    IF :NEW.Fecha_Fin_Pertenencia_Unidad < :NEW.Fecha_Inicio_Pertenencia_Unidad THEN
      RAISE_APPLICATION_ERROR(-20024, 'Error [Pertenencia BI]: Fecha fin de pertenencia no puede ser anterior a fecha inicio.');
    END IF;
    IF v_fecha_muerte IS NOT NULL AND :NEW.Fecha_Fin_Pertenencia_Unidad > v_fecha_muerte THEN
      :NEW.Fecha_Fin_Pertenencia_Unidad := v_fecha_muerte;
    END IF;
    IF v_unidad_disolucion IS NOT NULL AND :NEW.Fecha_Fin_Pertenencia_Unidad > v_unidad_disolucion THEN
      :NEW.Fecha_Fin_Pertenencia_Unidad := v_unidad_disolucion;
    END IF;
  END IF;

  IF :NEW.Fecha_Fin_Pertenencia_Unidad IS NULL THEN
    UPDATE Soldado_Pertenencia_Unidad
    SET Fecha_Fin_Pertenencia_Unidad = :NEW.Fecha_Inicio_Pertenencia_Unidad - 1
    WHERE ID_Soldado = :NEW.ID_Soldado
      AND Fecha_Fin_Pertenencia_Unidad IS NULL
      AND ID_Unidad != :NEW.ID_Unidad
      AND Fecha_Inicio_Pertenencia_Unidad < :NEW.Fecha_Inicio_Pertenencia_Unidad;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Gest_Periodo_Perten_Unid_BU
BEFORE UPDATE ON soldado_pertenencia_unidad
FOR EACH ROW
DECLARE
  v_fecha_nacimiento DATE;
  v_fecha_muerte DATE;
  v_unidad_creacion DATE;
  v_unidad_disolucion DATE;
  v_count NUMBER;
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP; -- Ensure this line from the other trigger is also present or merge triggers
  SELECT Fecha_Nacimiento, Fecha_Muerte INTO v_fecha_nacimiento, v_fecha_muerte FROM Soldado WHERE ID_Soldado = :NEW.ID_Soldado;
  SELECT Fecha_Activacion_Unidad, Fecha_Desactivacion_Unidad INTO v_unidad_creacion, v_unidad_disolucion FROM Unidad_Militar WHERE ID_Unidad = :NEW.ID_Unidad;

  IF :NEW.Fecha_Inicio_Pertenencia_Unidad < v_fecha_nacimiento THEN
    RAISE_APPLICATION_ERROR(-20025, 'Error [Pertenencia BU]: Fecha de inicio no puede ser anterior al nacimiento.');
  END IF;
  IF v_fecha_muerte IS NOT NULL AND :NEW.Fecha_Inicio_Pertenencia_Unidad > v_fecha_muerte THEN
    RAISE_APPLICATION_ERROR(-20026, 'Error [Pertenencia BU]: Fecha de inicio no puede ser posterior a la muerte.');
  END IF;
  IF v_unidad_creacion IS NOT NULL AND :NEW.Fecha_Inicio_Pertenencia_Unidad < v_unidad_creacion THEN
    RAISE_APPLICATION_ERROR(-20027, 'Error [Pertenencia BU]: Fecha de inicio no puede ser anterior a la activación de la unidad.');
  END IF;

  IF :NEW.Fecha_Fin_Pertenencia_Unidad IS NOT NULL THEN
    IF :NEW.Fecha_Fin_Pertenencia_Unidad < :NEW.Fecha_Inicio_Pertenencia_Unidad THEN
      RAISE_APPLICATION_ERROR(-20028, 'Error [Pertenencia BU]: Fecha fin no puede ser anterior a fecha inicio.');
    END IF;
    IF v_fecha_muerte IS NOT NULL AND :NEW.Fecha_Fin_Pertenencia_Unidad > v_fecha_muerte THEN
      :NEW.Fecha_Fin_Pertenencia_Unidad := v_fecha_muerte;
    END IF;
    IF v_unidad_disolucion IS NOT NULL AND :NEW.Fecha_Fin_Pertenencia_Unidad > v_unidad_disolucion THEN
      :NEW.Fecha_Fin_Pertenencia_Unidad := v_unidad_disolucion;
    END IF;
  END IF;

  IF :NEW.Fecha_Fin_Pertenencia_Unidad IS NULL AND :OLD.Fecha_Fin_Pertenencia_Unidad IS NOT NULL THEN
    UPDATE Soldado_Pertenencia_Unidad
    SET Fecha_Fin_Pertenencia_Unidad = :NEW.Fecha_Inicio_Pertenencia_Unidad - 1
    WHERE ID_Soldado = :NEW.ID_Soldado
      AND Fecha_Fin_Pertenencia_Unidad IS NULL
      AND ID_Pertenencia != :NEW.ID_Pertenencia
      AND Fecha_Inicio_Pertenencia_Unidad < :NEW.Fecha_Inicio_Pertenencia_Unidad;
  END IF;

  SELECT COUNT(*) INTO v_count FROM Soldado_Pertenencia_Unidad
  WHERE ID_Soldado = :NEW.ID_Soldado
    AND ID_Pertenencia != :NEW.ID_Pertenencia
    AND :NEW.Fecha_Inicio_Pertenencia_Unidad < COALESCE(Fecha_Fin_Pertenencia_Unidad, TO_DATE('9999-12-31','YYYY-MM-DD'))
    AND COALESCE(:NEW.Fecha_Fin_Pertenencia_Unidad, TO_DATE('9999-12-31','YYYY-MM-DD')) > Fecha_Inicio_Pertenencia_Unidad;
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20029, 'Error [Pertenencia BU]: El periodo de pertenencia se solapa con otro existente para este soldado.');
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Unidad_Militar_No_Auto_Sup_BU
BEFORE UPDATE ON unidad_militar
FOR EACH ROW
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP; -- Ensure this line from the other trigger is also present or merge triggers
  IF :NEW.ID_Unidad_Superior_Directa IS NOT NULL AND :NEW.ID_Unidad_Superior_Directa = :NEW.ID_Unidad THEN
    RAISE_APPLICATION_ERROR(-20030, 'Error [Unidad Militar BU]: Una unidad militar no puede ser su propia unidad superior directa.');
  END IF;
  -- Prevenir ciclos (A->B y B->A) es más complejo. Se puede hacer con un SP o en la aplicación, o una función recursiva en el trigger.
  -- Por simplicidad, esta comprobación básica se mantiene. Una comprobación más profunda requeriría una query recursiva.
END;
/


CREATE OR REPLACE TRIGGER TRG_Unidad_Mil_Cmd_Fechas_BI
BEFORE INSERT ON unidad_militar_comandante
FOR EACH ROW
DECLARE
  v_soldado_nacimiento DATE;
  v_soldado_muerte DATE;
  v_unidad_creacion DATE;
  v_unidad_disolucion DATE;
BEGIN
  SELECT Fecha_Nacimiento, Fecha_Muerte INTO v_soldado_nacimiento, v_soldado_muerte FROM Soldado WHERE ID_Soldado = :NEW.ID_Soldado_Comandante;
  SELECT Fecha_Activacion_Unidad, Fecha_Desactivacion_Unidad INTO v_unidad_creacion, v_unidad_disolucion FROM Unidad_Militar WHERE ID_Unidad = :NEW.ID_Unidad_Comandada;

  IF :NEW.Fecha_Inicio_Comando_Unidad < v_soldado_nacimiento THEN
    RAISE_APPLICATION_ERROR(-20031, 'Error [Comandante BI]: Fecha de inicio de comando no puede ser anterior al nacimiento del comandante.');
  END IF;
  IF v_soldado_muerte IS NOT NULL AND :NEW.Fecha_Inicio_Comando_Unidad > v_soldado_muerte THEN
    RAISE_APPLICATION_ERROR(-20032, 'Error [Comandante BI]: Fecha de inicio de comando no puede ser posterior a la muerte del comandante.');
  END IF;
  IF v_unidad_creacion IS NOT NULL AND :NEW.Fecha_Inicio_Comando_Unidad < v_unidad_creacion THEN
    RAISE_APPLICATION_ERROR(-20033, 'Error [Comandante BI]: Fecha de inicio de comando no puede ser anterior a la activación de la unidad.');
  END IF;

  IF :NEW.Fecha_Fin_Comando_Unidad IS NOT NULL THEN
    IF :NEW.Fecha_Fin_Comando_Unidad < :NEW.Fecha_Inicio_Comando_Unidad THEN
      RAISE_APPLICATION_ERROR(-20034, 'Error [Comandante BI]: Fecha fin de comando no puede ser anterior a fecha inicio.');
    END IF;
    IF v_soldado_muerte IS NOT NULL AND :NEW.Fecha_Fin_Comando_Unidad > v_soldado_muerte THEN
      :NEW.Fecha_Fin_Comando_Unidad := v_soldado_muerte;
    END IF;
    IF v_unidad_disolucion IS NOT NULL AND :NEW.Fecha_Fin_Comando_Unidad > v_unidad_disolucion THEN
      :NEW.Fecha_Fin_Comando_Unidad := v_unidad_disolucion;
    END IF;
  ELSE
    IF v_soldado_muerte IS NOT NULL THEN
      :NEW.Fecha_Fin_Comando_Unidad := v_soldado_muerte;
    ELSIF v_unidad_disolucion IS NOT NULL THEN
      :NEW.Fecha_Fin_Comando_Unidad := v_unidad_disolucion;
    END IF;
  END IF;

  IF v_unidad_disolucion IS NOT NULL AND :NEW.Fecha_Inicio_Comando_Unidad > v_unidad_disolucion THEN
    RAISE_APPLICATION_ERROR(-20035, 'Error [Comandante BI]: Fecha de inicio de comando no puede ser posterior a la desactivación de la unidad.');
  END IF;

  IF :NEW.Fecha_Fin_Comando_Unidad IS NULL THEN
    UPDATE Unidad_Militar_Comandante
    SET Fecha_Fin_Comando_Unidad = :NEW.Fecha_Inicio_Comando_Unidad - 1
    WHERE ID_Unidad_Comandada = :NEW.ID_Unidad_Comandada
      AND Fecha_Fin_Comando_Unidad IS NULL
      AND ID_Soldado_Comandante != :NEW.ID_Soldado_Comandante
      AND Fecha_Inicio_Comando_Unidad < :NEW.Fecha_Inicio_Comando_Unidad;
  END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_Unidad_Mil_Cmd_Fechas_BU
BEFORE UPDATE ON unidad_militar_comandante
FOR EACH ROW
DECLARE
  v_soldado_nacimiento DATE;
  v_soldado_muerte DATE;
  v_unidad_creacion DATE;
  v_unidad_disolucion DATE;
  v_count NUMBER;
BEGIN
  :NEW.Fecha_Actualizacion := SYSTIMESTAMP; -- Ensure this line from the other trigger is also present or merge triggers
  SELECT Fecha_Nacimiento, Fecha_Muerte INTO v_soldado_nacimiento, v_soldado_muerte FROM Soldado WHERE ID_Soldado = :NEW.ID_Soldado_Comandante;
  SELECT Fecha_Activacion_Unidad, Fecha_Desactivacion_Unidad INTO v_unidad_creacion, v_unidad_disolucion FROM Unidad_Militar WHERE ID_Unidad = :NEW.ID_Unidad_Comandada;

  IF :NEW.Fecha_Inicio_Comando_Unidad < v_soldado_nacimiento THEN
    RAISE_APPLICATION_ERROR(-20036, 'Error [Comandante BU]: Fecha de inicio de comando no puede ser anterior al nacimiento del comandante.');
  END IF;
  IF v_soldado_muerte IS NOT NULL AND :NEW.Fecha_Inicio_Comando_Unidad > v_soldado_muerte THEN
    RAISE_APPLICATION_ERROR(-20037, 'Error [Comandante BU]: Fecha de inicio de comando no puede ser posterior a la muerte del comandante.');
  END IF;
  IF v_unidad_creacion IS NOT NULL AND :NEW.Fecha_Inicio_Comando_Unidad < v_unidad_creacion THEN
    RAISE_APPLICATION_ERROR(-20038, 'Error [Comandante BU]: Fecha de inicio de comando no puede ser anterior a la activación de la unidad.');
  END IF;

  IF :NEW.Fecha_Fin_Comando_Unidad IS NOT NULL THEN
    IF :NEW.Fecha_Fin_Comando_Unidad < :NEW.Fecha_Inicio_Comando_Unidad THEN
      RAISE_APPLICATION_ERROR(-20039, 'Error [Comandante BU]: Fecha fin de comando no puede ser anterior a fecha inicio.');
    END IF;
    IF v_soldado_muerte IS NOT NULL AND :NEW.Fecha_Fin_Comando_Unidad > v_soldado_muerte THEN
      :NEW.Fecha_Fin_Comando_Unidad := v_soldado_muerte;
    END IF;
    IF v_unidad_disolucion IS NOT NULL AND :NEW.Fecha_Fin_Comando_Unidad > v_unidad_disolucion THEN
      :NEW.Fecha_Fin_Comando_Unidad := v_unidad_disolucion;
    END IF;
  ELSE
    IF v_soldado_muerte IS NOT NULL THEN
      :NEW.Fecha_Fin_Comando_Unidad := v_soldado_muerte;
    ELSIF v_unidad_disolucion IS NOT NULL THEN
      :NEW.Fecha_Fin_Comando_Unidad := v_unidad_disolucion;
    END IF;
  END IF;

  IF v_unidad_disolucion IS NOT NULL AND :NEW.Fecha_Inicio_Comando_Unidad > v_unidad_disolucion THEN
    RAISE_APPLICATION_ERROR(-20040, 'Error [Comandante BU]: Fecha de inicio de comando no puede ser posterior a la desactivación de la unidad.');
  END IF;

  IF :NEW.Fecha_Fin_Comando_Unidad IS NULL AND :OLD.Fecha_Fin_Comando_Unidad IS NOT NULL THEN
    UPDATE Unidad_Militar_Comandante
    SET Fecha_Fin_Comando_Unidad = :NEW.Fecha_Inicio_Comando_Unidad - 1
    WHERE ID_Unidad_Comandada = :NEW.ID_Unidad_Comandada
      AND Fecha_Fin_Comando_Unidad IS NULL
      AND ID_Comandancia != :NEW.ID_Comandancia
      AND Fecha_Inicio_Comando_Unidad < :NEW.Fecha_Inicio_Comando_Unidad;
  END IF;

  SELECT COUNT(*) INTO v_count FROM Unidad_Militar_Comandante
  WHERE ID_Unidad_Comandada = :NEW.ID_Unidad_Comandada
    AND ID_Comandancia != :NEW.ID_Comandancia
    AND :NEW.Fecha_Inicio_Comando_Unidad < COALESCE(Fecha_Fin_Comando_Unidad, TO_DATE('9999-12-31','YYYY-MM-DD'))
    AND COALESCE(:NEW.Fecha_Fin_Comando_Unidad, TO_DATE('9999-12-31','YYYY-MM-DD')) > Fecha_Inicio_Comando_Unidad;
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20041, 'Error [Comandante BU]: El periodo de comando se solapa con otro existente para esta unidad.');
  END IF;
END;
/

-- PROCEDIMIENTOS (Conversión de sintaxis, la lógica de hashing y email se debe adaptar a Oracle)

CREATE OR REPLACE PROCEDURE SP_Buscar_Soldados_Avanzado (
    p_Termino_Nombre          IN VARCHAR2,
    p_ID_Pais_Origen          IN NUMBER,
    p_ID_Rama_Ejercito        IN NUMBER,
    p_ID_Rango_Ostentado      IN NUMBER,
    p_ID_Unidad_Pertenecio    IN NUMBER,
    p_Anio_Nacimiento_Desde   IN NUMBER,
    p_Anio_Nacimiento_Hasta   IN NUMBER,
    p_Anio_Muerte_Desde       IN NUMBER,
    p_Anio_Muerte_Hasta       IN NUMBER,
    p_ID_Batalla_Participo    IN NUMBER,
    p_ID_Medalla_Obtenida     IN NUMBER,
    p_Limit                   IN NUMBER,
    p_Offset                  IN NUMBER,
    p_Resultado               OUT SYS_REFCURSOR -- Usar un cursor para devolver resultados
)
AS
  v_sql_query VARCHAR2(4000);
  v_joins     VARCHAR2(1000) := '';
  v_conditions VARCHAR2(2000) := 'WHERE 1=1 ';
BEGIN
  v_sql_query := 'SELECT S.* FROM V_Soldado_Informacion_Completa S '; -- Asumiendo que V_Soldado_Informacion_Completa existe y está adaptada

  IF p_ID_Rango_Ostentado IS NOT NULL THEN
    v_joins := v_joins || 'LEFT JOIN Soldado_Ascenso SA ON S.ID_Soldado = SA.ID_Soldado ';
    v_conditions := v_conditions || 'AND SA.ID_Rango = ' || p_ID_Rango_Ostentado || ' ';
  END IF;
  IF p_ID_Unidad_Pertenecio IS NOT NULL THEN
    v_joins := v_joins || 'LEFT JOIN Soldado_Pertenencia_Unidad SPU ON S.ID_Soldado = SPU.ID_Soldado ';
    v_conditions := v_conditions || 'AND SPU.ID_Unidad = ' || p_ID_Unidad_Pertenecio || ' ';
  END IF;
  IF p_ID_Batalla_Participo IS NOT NULL THEN
    v_joins := v_joins || 'LEFT JOIN Soldado_Participacion_Batalla SPB ON S.ID_Soldado = SPB.ID_Soldado ';
    v_conditions := v_conditions || 'AND SPB.ID_Batalla = ' || p_ID_Batalla_Participo || ' ';
  END IF;
  IF p_ID_Medalla_Obtenida IS NOT NULL THEN
    v_joins := v_joins || 'LEFT JOIN Soldado_Medalla SM ON S.ID_Soldado = SM.ID_Soldado ';
    v_conditions := v_conditions || 'AND SM.ID_Medalla = ' || p_ID_Medalla_Obtenida || ' ';
  END IF;

  IF p_Termino_Nombre IS NOT NULL AND p_Termino_Nombre != '' THEN
    v_conditions := v_conditions || 'AND S.Nombre_Completo_Busqueda LIKE ''%' || REPLACE(p_Termino_Nombre, '''', '''''') || '%'' ';
  END IF;
  IF p_ID_Pais_Origen IS NOT NULL THEN
    v_conditions := v_conditions || 'AND S.Pais_Origen_Nombre = (SELECT Nombre_Pais FROM Pais WHERE ID_Pais = ' || p_ID_Pais_Origen || ') ';
  END IF;
  IF p_ID_Rama_Ejercito IS NOT NULL THEN
    v_conditions := v_conditions || 'AND S.Rama_Ejercito_Nombre = (SELECT Nombre_Rama FROM Rama_Ejercito WHERE ID_Rama_Ejercito = ' || p_ID_Rama_Ejercito || ') ';
  END IF;
  IF p_Anio_Nacimiento_Desde IS NOT NULL THEN
    v_conditions := v_conditions || 'AND EXTRACT(YEAR FROM S.Fecha_Nacimiento) >= ' || p_Anio_Nacimiento_Desde || ' ';
  END IF;
  IF p_Anio_Nacimiento_Hasta IS NOT NULL THEN
    v_conditions := v_conditions || 'AND EXTRACT(YEAR FROM S.Fecha_Nacimiento) <= ' || p_Anio_Nacimiento_Hasta || ' ';
  END IF;
  IF p_Anio_Muerte_Desde IS NOT NULL THEN
    v_conditions := v_conditions || 'AND (S.Fecha_Muerte IS NULL OR EXTRACT(YEAR FROM S.Fecha_Muerte) >= ' || p_Anio_Muerte_Desde || ') ';
  END IF;
  IF p_Anio_Muerte_Hasta IS NOT NULL THEN
    v_conditions := v_conditions || 'AND (S.Fecha_Muerte IS NULL OR EXTRACT(YEAR FROM S.Fecha_Muerte) <= ' || p_Anio_Muerte_Hasta || ') ';
  END IF;

  v_sql_query := v_sql_query || v_joins || v_conditions || 'ORDER BY S.Apellidos, S.Nombres ';

  IF p_Limit IS NOT NULL AND p_Offset IS NOT NULL THEN
    -- Oracle 12c+ syntax for pagination
    v_sql_query := v_sql_query || 'OFFSET ' || p_Offset || ' ROWS FETCH NEXT ' || p_Limit || ' ROWS ONLY';
  ELSIF p_Limit IS NOT NULL THEN
    v_sql_query := 'SELECT * FROM (' || v_sql_query || ') WHERE ROWNUM <= ' || p_Limit;
  END IF;

  OPEN p_Resultado FOR v_sql_query;

END SP_Buscar_Soldados_Avanzado;
/


CREATE OR REPLACE PROCEDURE SP_Gestionar_Usuario_Sistema (
    p_Accion                      IN VARCHAR2, -- ENUM values as VARCHAR2
    p_Correo_Electronico          IN VARCHAR2,
    p_Nombres_Usuario             IN VARCHAR2,
    p_Apellidos_Usuario           IN VARCHAR2,
    p_ID_Pais_Origen_Usuario      IN NUMBER,
    p_Password_Actual             IN VARCHAR2,
    p_Password_Nuevo              IN VARCHAR2,
    p_Rol_Usuario_Sistema         IN VARCHAR2, -- ENUM values as VARCHAR2
    p_Estado_Cuenta_Usuario       IN VARCHAR2, -- ENUM values as VARCHAR2
    p_Token                       IN VARCHAR2,
    p_Mensaje_Resultado           OUT VARCHAR2,
    p_Exito                       OUT BOOLEAN
)
AS
  v_Password_Hash VARCHAR2(255);
  v_Usuario_Existe NUMBER;
  v_Correo_Verificado VARCHAR2(255);
  v_Token_Verificacion VARCHAR2(100);
BEGIN
  p_Exito := FALSE;

  SELECT COUNT(*) INTO v_Usuario_Existe FROM Usuario_Sistema WHERE Correo_Electronico = p_Correo_Electronico;

  CASE p_Accion
    WHEN 'REGISTRAR' THEN
      IF v_Usuario_Existe > 0 THEN
        p_Mensaje_Resultado := 'Error: El correo electrónico ya está registrado.';
      ELSIF p_Password_Nuevo IS NULL OR LENGTH(p_Password_Nuevo) < 8 THEN
        p_Mensaje_Resultado := 'Error: La contraseña debe tener al menos 8 caracteres.';
      ELSE
        -- En una aplicación real, aquí se generaría un hash seguro para p_Password_Nuevo
        -- Usar DBMS_CRYPTO.HASH para SHA256, SHA512 o bcrypt/Argon2 si hay una librería PL/SQL
        v_Password_Hash := p_Password_Nuevo; -- Placeholder - NUNCA ALMACENAR ASÍ
        v_Token_Verificacion := SYS_GUID(); -- Generar un UUID

        INSERT INTO Usuario_Sistema (
            Correo_Electronico, Nombres_Usuario, Apellidos_Usuario, ID_Pais_Origen_Usuario,
            Password_Hash_Usuario, Rol_Usuario_Sistema, Estado_Cuenta_Usuario,
            Token_Verificacion_Email, Fecha_Expiracion_Token_Verificacion
        ) VALUES (
            p_Correo_Electronico, p_Nombres_Usuario, p_Apellidos_Usuario, p_ID_Pais_Origen_Usuario,
            v_Password_Hash, COALESCE(p_Rol_Usuario_Sistema, 'Consultor Registrado'),
            'Pendiente Verificacion Email', v_Token_Verificacion, SYSTIMESTAMP + INTERVAL '1' DAY
        );
        p_Mensaje_Resultado := 'Usuario registrado. Se ha enviado un correo de verificación a ' || p_Correo_Electronico || '. Token: ' || v_Token_Verificacion;
        p_Exito := TRUE;
        -- Aquí se enviaría el email con el token de verificación.
      END IF;

    WHEN 'VERIFICAR_EMAIL' THEN
      BEGIN
        SELECT Correo_Electronico INTO v_Correo_Verificado FROM Usuario_Sistema
        WHERE Token_Verificacion_Email = p_Token
          AND Fecha_Expiracion_Token_Verificacion > SYSTIMESTAMP
          AND Estado_Cuenta_Usuario = 'Pendiente Verificacion Email';

        IF v_Correo_Verificado IS NOT NULL THEN
          UPDATE Usuario_Sistema SET Estado_Cuenta_Usuario = 'Activo', Token_Verificacion_Email = NULL, Fecha_Expiracion_Token_Verificacion = NULL
          WHERE Correo_Electronico = v_Correo_Verificado;
          p_Mensaje_Resultado := 'Correo electrónico verificado exitosamente. Ya puede iniciar sesión.';
          p_Exito := TRUE;
        ELSE
          p_Mensaje_Resultado := 'Error: Token de verificación inválido o expirado.';
        END IF;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          p_Mensaje_Resultado := 'Error: Token de verificación inválido o expirado.';
      END;
    -- Otros casos como ACTUALIZAR_PERFIL, CAMBIAR_PASSWORD, etc. seguirían una lógica similar.
    -- Por brevedad, no se implementan todos aquí.
    ELSE
      p_Mensaje_Resultado := 'Acción no reconocida.';
  END CASE;
EXCEPTION
    WHEN OTHERS THEN
        p_Exito := FALSE;
        p_Mensaje_Resultado := 'Error inesperado en SP_Gestionar_Usuario_Sistema: ' || SQLERRM;
END SP_Gestionar_Usuario_Sistema;
/

CREATE OR REPLACE PROCEDURE SP_Obtener_Linea_Tiempo_Soldado (
    p_ID_Soldado IN NUMBER,
    p_Resultado OUT SYS_REFCURSOR
)
AS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM Soldado WHERE ID_Soldado = p_ID_Soldado;
  IF v_count = 0 THEN
    -- Devolver un cursor vacío o un mensaje. Para DDL Modeler, un cursor vacío es suficiente.
    -- Si necesitas un mensaje, podrías añadir otro parámetro OUT o usar RAISE_APPLICATION_ERROR.
    -- Aquí, si no existe, el cursor simplemente no devolverá filas.
    OPEN p_Resultado FOR
        SELECT 'Error: El soldado especificado no existe.' AS Mensaje_Error FROM DUAL WHERE 1=0; -- No rows
  ELSE
    -- Asumiendo que V_Linea_Tiempo_Eventos_Soldado existe y está adaptada
    OPEN p_Resultado FOR
      SELECT VLT.Fecha_Evento, VLT.Tipo_Evento, VLT.Descripcion_Detallada_Evento, VLT.ID_Registro_Relacionado,
             L.Nombre_Lugar AS Nombre_Lugar_Evento, P.Nombre_Pais AS Nombre_Pais_Evento
      FROM V_Linea_Tiempo_Eventos_Soldado VLT -- Esta vista necesita ser convertida también
      LEFT JOIN Lugar L ON VLT.ID_Lugar_Evento = L.ID_Lugar
      LEFT JOIN Pais P ON L.ID_Pais = P.ID_Pais
      WHERE VLT.ID_Soldado = p_ID_Soldado
      ORDER BY VLT.Fecha_Evento ASC, VLT.Orden_Tipo_Evento ASC;
  END IF;
END SP_Obtener_Linea_Tiempo_Soldado;
/


-- VISTAS (Se necesita convertir la lógica interna de las vistas)
-- Esta es una tarea compleja ya que las funciones de MySQL y Oracle pueden diferir.
-- Proporcionaré la estructura y señalaré las conversiones necesarias.

-- V_ESTADISTICAS_BAJAS_POR_BATALLA
CREATE OR REPLACE VIEW v_estadisticas_bajas_por_batalla AS
SELECT
  b.ID_Batalla,
  b.Nombre_Batalla,
  p.Nombre_Pais AS Pais_Donde_Ocurrio_Batalla,
  b.Fecha_Inicio_Batalla,
  b.Fecha_Fin_Batalla,
  COUNT(DISTINCT spb.ID_Soldado) AS Numero_Participantes_Registrados_Sistema,
  SUM(CASE WHEN spb.Estado_Soldado_Post_Batalla = 'Caído en Combate (KIA)' THEN 1 ELSE 0 END) AS Bajas_En_Combate_Registradas_Sistema,
  SUM(CASE WHEN spb.Estado_Soldado_Post_Batalla LIKE 'Herido%' THEN 1 ELSE 0 END) AS Heridos_Registrados_Sistema,
  SUM(CASE WHEN spb.Estado_Soldado_Post_Batalla = 'Prisionero de Guerra (POW)' THEN 1 ELSE 0 END) AS Prisioneros_Registrados_Sistema,
  SUM(CASE WHEN spb.Estado_Soldado_Post_Batalla = 'Desaparecido en Acción (MIA)' THEN 1 ELSE 0 END) AS Desaparecidos_Registrados_Sistema,
  b.Bajas_Estimadas_Eje AS Bajas_Totales_Estimadas_Eje_Historicas,
  b.Bajas_Estimadas_Aliados AS Bajas_Totales_Estimadas_Aliados_Historicas
FROM batalla b
JOIN pais p ON b.ID_Pais_Batalla = p.ID_Pais
LEFT JOIN soldado_participacion_batalla spb ON b.ID_Batalla = spb.ID_Batalla
GROUP BY
  b.ID_Batalla, b.Nombre_Batalla, p.Nombre_Pais, b.Fecha_Inicio_Batalla, b.Fecha_Fin_Batalla,
  b.Bajas_Estimadas_Eje, b.Bajas_Estimadas_Aliados
ORDER BY b.Fecha_Inicio_Batalla, b.Nombre_Batalla;

-- V_ESTADISTICAS_SOLDADOS_POR_PAIS_ORIGEN
CREATE OR REPLACE VIEW v_estadisticas_soldados_por_pais_origen AS
SELECT
  p.Nombre_Pais AS Pais_Origen,
  p.Codigo_ISO_Alfa2 AS Codigo_Pais_ISO2,
  COUNT(s.ID_Soldado) AS Numero_Total_Soldados_Registrados,
  SUM(CASE WHEN s.Fecha_Muerte IS NOT NULL THEN 1 ELSE 0 END) AS Numero_Soldados_Caidos_Confirmados,
  ROUND(AVG( (s.Fecha_Muerte - s.Fecha_Nacimiento) / 365.25 ), 1) AS Edad_Promedio_Al_Morir_Anios -- MySQL: timestampdiff(YEAR,...)
FROM soldado s
JOIN pais p ON s.ID_Pais_Origen = p.ID_Pais
GROUP BY p.ID_Pais, p.Nombre_Pais, p.Codigo_ISO_Alfa2
ORDER BY COUNT(s.ID_Soldado) DESC;

-- V_INFORMACION_INHUMACION_PRESENTACION
CREATE OR REPLACE VIEW v_informacion_inhumacion_presentacion AS
SELECT
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda AS Nombre_Soldado,
  COALESCE(li.Es_Inhumacion_Desconocida_Confirmado, 1) AS Inhumacion_Es_Desconocida_Flag,
  li.Tipo_Sitio_Inhumacion,
  CASE
    WHEN li.ID_Soldado IS NULL OR li.Es_Inhumacion_Desconocida_Confirmado = 1 THEN pmuer.Nombre_Pais
    ELSE pinhu.Nombre_Pais
  END AS Pais_Referencia_Inhumacion_Nombre,
  CASE
    WHEN li.ID_Soldado IS NULL OR li.Es_Inhumacion_Desconocida_Confirmado = 1 THEN lmuer.Nombre_Lugar
    WHEN li.ID_Lugar_Inhumacion_Detallado IS NOT NULL THEN linhudet.Nombre_Lugar
    ELSE li.Lugar_Detallado_Texto_Inhumacion
  END AS Lugar_Referencia_Inhumacion_Nombre,
  CASE
    WHEN li.ID_Soldado IS NULL OR li.Es_Inhumacion_Desconocida_Confirmado = 1 THEN NULL
    ELSE li.Nombre_Cementerio_Memorial
  END AS Nombre_Cementerio_O_Memorial,
  CASE
    WHEN li.ID_Soldado IS NULL OR li.Es_Inhumacion_Desconocida_Confirmado = 1 THEN NULL
    ELSE li.Ubicacion_Exacta_Tumba
  END AS Ubicacion_Exacta_Tumba_En_Sitio,
  CASE
    WHEN li.ID_Soldado IS NULL THEN 'No hay datos de inhumación registrados para este soldado.'
    WHEN li.Es_Inhumacion_Desconocida_Confirmado = 1 THEN li.Anotacion_Lugar_Desconocido
    ELSE 'Información de inhumación conocida y registrada.'
  END AS Anotacion_Sobre_Inhumacion,
  li.Coordenadas_Sitio_Lat,
  li.Coordenadas_Sitio_Lon,
  li.Fotografia_Tumba_URL,
  s.Fecha_Muerte AS Fecha_Muerte_Soldado_Contexto,
  lmuer.Nombre_Lugar AS Lugar_Muerte_Si_Inhumacion_Desconocida_Contexto
FROM soldado s
LEFT JOIN lugar_inhumacion li ON s.ID_Soldado = li.ID_Soldado
LEFT JOIN pais pinhu ON li.ID_Pais_Inhumacion = pinhu.ID_Pais
LEFT JOIN lugar linhudet ON li.ID_Lugar_Inhumacion_Detallado = linhudet.ID_Lugar
LEFT JOIN lugar lmuer ON s.ID_Lugar_Muerte = lmuer.ID_Lugar
LEFT JOIN pais pmuer ON lmuer.ID_Pais = pmuer.ID_Pais;

-- V_LINEA_TIEMPO_EVENTOS_SOLDADO
CREATE OR REPLACE VIEW v_linea_tiempo_eventos_soldado AS
SELECT
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda AS Nombre_Soldado,
  s.Fecha_Nacimiento AS Fecha_Evento,
  1 AS Orden_Tipo_Evento,
  'Nacimiento' AS Tipo_Evento,
  'Nació en ' || lnac.Nombre_Lugar || ', ' || pnac.Nombre_Pais || '. Precisión fecha: ' || s.Fecha_Nacimiento_Precision AS Descripcion_Detallada_Evento,
  NULL AS ID_Registro_Relacionado,
  lnac.ID_Lugar AS ID_Lugar_Evento
FROM soldado s
JOIN lugar lnac ON s.ID_Lugar_Nacimiento = lnac.ID_Lugar
JOIN pais pnac ON lnac.ID_Pais = pnac.ID_Pais
UNION ALL
SELECT
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda,
  sa.Fecha_Inicio_Rango,
  2 AS Orden_Tipo_Evento,
  'Ascenso Militar' AS Tipo_Evento,
  'Ascendido al rango de: ' || r.Nombre_Rango ||
  COALESCE('. Documento: ' || sa.Documento_Referencia_Ascenso, '') ||
  COALESCE('. Notas: ' || sa.Notas_Adicionales_Ascenso, '') AS Descripcion_Detallada_Evento,
  sa.ID_Soldado_Ascenso AS ID_Registro_Relacionado,
  NULL AS ID_Lugar_Evento
FROM soldado_ascenso sa
JOIN soldado s ON sa.ID_Soldado = s.ID_Soldado
JOIN rango r ON sa.ID_Rango = r.ID_Rango
UNION ALL
SELECT
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda,
  spu.Fecha_Inicio_Pertenencia_Unidad,
  3 AS Orden_Tipo_Evento,
  'Inicio Pertenencia a Unidad' AS Tipo_Evento,
  'Se unió a la unidad: ' || um.Nombre_Unidad || ' (' || um.Tipo_Unidad || ')' ||
  COALESCE(' como ' || spu.Rol_Desempenado_En_Unidad, '') ||
  COALESCE('. Notas: ' || spu.Notas_Sobre_Pertenencia, '') AS Descripcion_Detallada_Evento,
  spu.ID_Pertenencia AS ID_Registro_Relacionado,
  NULL AS ID_Lugar_Evento
FROM soldado_pertenencia_unidad spu
JOIN soldado s ON spu.ID_Soldado = s.ID_Soldado
JOIN unidad_militar um ON spu.ID_Unidad = um.ID_Unidad
UNION ALL
SELECT
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda,
  spu.Fecha_Fin_Pertenencia_Unidad,
  6 AS Orden_Tipo_Evento, -- Order after death if dates coincide for some reason
  'Fin Pertenencia a Unidad' AS Tipo_Evento,
  'Dejó la unidad: ' || um.Nombre_Unidad ||
  COALESCE('. Notas: ' || spu.Notas_Sobre_Pertenencia, '') AS Descripcion_Detallada_Evento,
  spu.ID_Pertenencia AS ID_Registro_Relacionado,
  NULL AS ID_Lugar_Evento
FROM soldado_pertenencia_unidad spu
JOIN soldado s ON spu.ID_Soldado = s.ID_Soldado
JOIN unidad_militar um ON spu.ID_Unidad = um.ID_Unidad
WHERE spu.Fecha_Fin_Pertenencia_Unidad IS NOT NULL
UNION ALL
SELECT
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda,
  COALESCE(spb.Fecha_Inicio_Participacion_Batalla, b.Fecha_Inicio_Batalla) AS Fecha_Evento,
  4 AS Orden_Tipo_Evento,
  'Participación en Batalla' AS Tipo_Evento,
  'Participó en la Batalla de: ' || b.Nombre_Batalla ||
  CASE WHEN spb.Rol_O_Acciones_En_Batalla IS NOT NULL THEN ' (Rol: ' || spb.Rol_O_Acciones_En_Batalla || ')' ELSE '' END ||
  CASE WHEN spb.Estado_Soldado_Post_Batalla IS NOT NULL THEN ' [Estado final: ' || spb.Estado_Soldado_Post_Batalla || ']' ELSE '' END ||
  COALESCE('. Notas: ' || spb.Notas_Participacion_Batalla, '') AS Descripcion_Detallada_Evento,
  spb.ID_Participacion_Batalla AS ID_Registro_Relacionado,
  b.ID_Lugar_Batalla AS ID_Lugar_Evento
FROM soldado_participacion_batalla spb
JOIN soldado s ON spb.ID_Soldado = s.ID_Soldado
JOIN batalla b ON spb.ID_Batalla = b.ID_Batalla
UNION ALL
SELECT
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda,
  sm.Fecha_Obtencion_Medalla,
  5 AS Orden_Tipo_Evento,
  'Condecoración Recibida' AS Tipo_Evento,
  'Recibió la medalla: ' || m.Nombre_Medalla ||
  CASE WHEN sm.Motivo_Condecoracion_Especifico IS NOT NULL THEN '. Motivo: ' || sm.Motivo_Condecoracion_Especifico ELSE '' END ||
  CASE WHEN sm.Otorgada_Postumamente = 1 THEN ' (Póstuma)' ELSE '' END AS Descripcion_Detallada_Evento,
  sm.ID_Soldado_Medalla AS ID_Registro_Relacionado,
  NULL AS ID_Lugar_Evento
FROM soldado_medalla sm
JOIN soldado s ON sm.ID_Soldado = s.ID_Soldado
JOIN medalla m ON sm.ID_Medalla = m.ID_Medalla
WHERE sm.Fecha_Obtencion_Medalla IS NOT NULL
UNION ALL
SELECT
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda,
  s.Fecha_Muerte,
  7 AS Orden_Tipo_Evento,
  'Fallecimiento' AS Tipo_Evento,
  'Falleció en: ' || lmuer.Nombre_Lugar || ', ' || pmuer.Nombre_Pais ||
  '. Causa: ' || COALESCE(cm.Descripcion_Causa, 'Desconocida') ||
  '. Precisión fecha: ' || s.Fecha_Muerte_Precision AS Descripcion_Detallada_Evento,
  NULL AS ID_Registro_Relacionado,
  s.ID_Lugar_Muerte AS ID_Lugar_Evento
FROM soldado s
LEFT JOIN lugar lmuer ON s.ID_Lugar_Muerte = lmuer.ID_Lugar
LEFT JOIN pais pmuer ON lmuer.ID_Pais = pmuer.ID_Pais
LEFT JOIN causa_muerte cm ON s.ID_Causa_Muerte = cm.ID_Causa_Muerte
WHERE s.Fecha_Muerte IS NOT NULL;

-- V_SOLDADO_INFORMACION_COMPLETA
CREATE OR REPLACE VIEW v_soldado_informacion_completa AS
SELECT
  s.ID_Soldado,
  s.Nombres,
  s.Patronimico,
  s.Apellidos,
  s.Nombre_Completo_Busqueda,
  s.Sexo,
  s.Fecha_Nacimiento,
  s.Fecha_Nacimiento_Precision,
  porig.Nombre_Pais AS Pais_Origen_Nombre,
  porig.Codigo_ISO_Alfa2 AS Pais_Origen_ISO2,
  lnac.Nombre_Lugar AS Lugar_Nacimiento_Nombre,
  pnac.Nombre_Pais AS Pais_Lugar_Nacimiento_Nombre,
  lnac.Tipo_Lugar AS Tipo_Lugar_Nacimiento,
  s.Fecha_Muerte,
  s.Fecha_Muerte_Precision,
  lmuer.Nombre_Lugar AS Lugar_Muerte_Nombre,
  pmuer.Nombre_Pais AS Pais_Lugar_Muerte_Nombre,
  lmuer.Tipo_Lugar AS Tipo_Lugar_Muerte,
  cm.Descripcion_Causa AS Causa_Muerte_Descripcion,
  cm.Categoria_Causa AS Categoria_Causa_Muerte,
  re.Nombre_Rama AS Rama_Ejercito_Nombre,
  re.Siglas_Rama AS Rama_Ejercito_Siglas,
  s.Numero_Identificacion_Militar,
  s.Notas_Adicionales_Soldado,
  s.Fotografia_URL,
  s.Estado_Registro,
  s.Fuente_Informacion_Principal,
  s.Fecha_Creacion AS Fecha_Registro_Soldado_DB,
  s.Fecha_Actualizacion AS Ultima_Actualizacion_Soldado_DB
FROM soldado s
JOIN pais porig ON s.ID_Pais_Origen = porig.ID_Pais
JOIN lugar lnac ON s.ID_Lugar_Nacimiento = lnac.ID_Lugar
JOIN pais pnac ON lnac.ID_Pais = pnac.ID_Pais
LEFT JOIN lugar lmuer ON s.ID_Lugar_Muerte = lmuer.ID_Lugar
LEFT JOIN pais pmuer ON lmuer.ID_Pais = pmuer.ID_Pais
LEFT JOIN causa_muerte cm ON s.ID_Causa_Muerte = cm.ID_Causa_Muerte
LEFT JOIN rama_ejercito re ON s.ID_Rama_Ejercito = re.ID_Rama_Ejercito;

-- V_SOLDADO_PARTICIPACION_BATALLAS_DETALLADA
CREATE OR REPLACE VIEW v_soldado_participacion_batallas_detallada AS
SELECT
  spb.ID_Participacion_Batalla,
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda AS Nombre_Soldado,
  b.ID_Batalla,
  b.Nombre_Batalla,
  pbat.Nombre_Pais AS Pais_Batalla,
  COALESCE(lb.Nombre_Lugar, b.Lugar_Especifico_Texto) AS Lugar_Especifico_Batalla_Nombre,
  b.Fecha_Inicio_Batalla,
  b.Fecha_Fin_Batalla,
  (COALESCE(b.Fecha_Fin_Batalla, b.Fecha_Inicio_Batalla) - b.Fecha_Inicio_Batalla) + 1 AS Duracion_Total_Batalla_Dias, -- MySQL: timestampdiff(DAY,...) + 1
  cm.Nombre_Oficial_Campana,
  cm.Nombre_Codigo_Operacion,
  umbat.Nombre_Unidad AS Unidad_Militar_En_Batalla_Nombre,
  umbat.Tipo_Unidad AS Tipo_Unidad_Militar_En_Batalla,
  spb.Rol_O_Acciones_En_Batalla,
  spb.Estado_Soldado_Post_Batalla,
  spb.Fecha_Inicio_Participacion_Batalla,
  spb.Fecha_Fin_Participacion_Batalla,
  spb.Notas_Participacion_Batalla
FROM soldado_participacion_batalla spb
JOIN soldado s ON spb.ID_Soldado = s.ID_Soldado
JOIN batalla b ON spb.ID_Batalla = b.ID_Batalla
JOIN pais pbat ON b.ID_Pais_Batalla = pbat.ID_Pais
LEFT JOIN lugar lb ON b.ID_Lugar_Batalla = lb.ID_Lugar
LEFT JOIN campana_militar cm ON b.ID_Campana = cm.ID_Campana
LEFT JOIN unidad_militar umbat ON spb.ID_Unidad_Militar_En_Batalla = umbat.ID_Unidad
ORDER BY s.ID_Soldado, b.Fecha_Inicio_Batalla, spb.Fecha_Inicio_Participacion_Batalla;

-- V_SOLDADO_RANGOS_ACTUAL_HISTORIAL
CREATE OR REPLACE VIEW v_soldado_rangos_actual_historial AS
SELECT
  sa.ID_Soldado_Ascenso,
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda AS Nombre_Soldado,
  r.Nombre_Rango,
  r.Abreviatura_Rango,
  r.Orden_Jerarquico,
  sa.Fecha_Inicio_Rango,
  sa.Fecha_Fin_Rango,
  CASE
    WHEN sa.Fecha_Fin_Rango IS NULL AND s.Fecha_Muerte IS NULL THEN 'Rango Actual (Vivo)'
    WHEN sa.Fecha_Fin_Rango IS NULL AND s.Fecha_Muerte IS NOT NULL AND sa.Fecha_Inicio_Rango <= s.Fecha_Muerte THEN 'Rango al Morir'
    WHEN sa.Fecha_Fin_Rango IS NOT NULL AND s.Fecha_Muerte IS NOT NULL AND sa.Fecha_Fin_Rango >= s.Fecha_Muerte AND sa.Fecha_Inicio_Rango <= s.Fecha_Muerte THEN 'Rango al Morir'
    ELSE 'Rango Pasado'
  END AS Estado_Rango_Interpretado,
  sa.Documento_Referencia_Ascenso,
  sa.Notas_Adicionales_Ascenso
FROM soldado_ascenso sa
JOIN soldado s ON sa.ID_Soldado = s.ID_Soldado
JOIN rango r ON sa.ID_Rango = r.ID_Rango
ORDER BY s.ID_Soldado, sa.Fecha_Inicio_Rango DESC;

-- V_SOLDADO_UNIDADES_ACTUAL_HISTORIAL
CREATE OR REPLACE VIEW v_soldado_unidades_actual_historial AS
SELECT
  spu.ID_Pertenencia,
  s.ID_Soldado,
  s.Nombre_Completo_Busqueda AS Nombre_Soldado,
  um.ID_Unidad,
  um.Nombre_Unidad,
  um.Tipo_Unidad,
  puni.Nombre_Pais AS Pais_Afiliacion_Unidad,
  spu.Fecha_Inicio_Pertenencia_Unidad,
  spu.Fecha_Fin_Pertenencia_Unidad,
  CASE
    WHEN spu.Fecha_Fin_Pertenencia_Unidad IS NULL AND s.Fecha_Muerte IS NULL THEN 'Unidad Actual (Vivo)'
    WHEN spu.Fecha_Fin_Pertenencia_Unidad IS NULL AND s.Fecha_Muerte IS NOT NULL AND spu.Fecha_Inicio_Pertenencia_Unidad <= s.Fecha_Muerte THEN 'Unidad al Morir'
    WHEN spu.Fecha_Fin_Pertenencia_Unidad IS NOT NULL AND s.Fecha_Muerte IS NOT NULL AND spu.Fecha_Fin_Pertenencia_Unidad >= s.Fecha_Muerte AND spu.Fecha_Inicio_Pertenencia_Unidad <= s.Fecha_Muerte THEN 'Unidad al Morir'
    ELSE 'Pertenencia Pasada'
  END AS Estado_Pertenencia_Interpretado,
  spu.Rol_Desempenado_En_Unidad,
  spu.Notas_Sobre_Pertenencia
FROM soldado_pertenencia_unidad spu
JOIN soldado s ON spu.ID_Soldado = s.ID_Soldado
JOIN unidad_militar um ON spu.ID_Unidad = um.ID_Unidad
LEFT JOIN pais puni ON um.ID_Pais_Afiliacion_Unidad = puni.ID_Pais
ORDER BY s.ID_Soldado, spu.Fecha_Inicio_Pertenencia_Unidad DESC;

-- V_UNIDAD_MILITAR_JERARQUIA_COMPLETA
-- Oracle recursive CTEs do not use the `RECURSIVE` keyword.
-- SYS_CONNECT_BY_PATH is an alternative for hierarchical string concatenation.
-- This is a simplified conversion, a full recursive CTE in Oracle would look slightly different.
-- The MySQL version uses `CAST(... AS CHAR(2000) CHARSET utf8mb4)`. In Oracle, VARCHAR2(2000 CHAR) is fine.

CREATE OR REPLACE VIEW v_unidad_militar_jerarquia_completa AS
WITH UnidadJerarquia (
    ID_Unidad, Nombre_Unidad, Tipo_Unidad, ID_Unidad_Superior,
    Nivel_Jerarquia, Ruta_Jerarquia_Nombres, Ruta_Jerarquia_IDs
) AS (
  SELECT
    um.ID_Unidad,
    um.Nombre_Unidad,
    um.Tipo_Unidad,
    um.ID_Unidad_Superior_Directa,
    0 AS Nivel_Jerarquia,
    CAST(um.Nombre_Unidad AS VARCHAR2(4000 CHAR)), -- Max length in SYS_CONNECT_BY_PATH is 4000
    CAST(um.ID_Unidad AS VARCHAR2(4000 CHAR))
  FROM unidad_militar um
  WHERE um.ID_Unidad_Superior_Directa IS NULL
  UNION ALL
  SELECT
    um_hija.ID_Unidad,
    um_hija.Nombre_Unidad,
    um_hija.Tipo_Unidad,
    um_hija.ID_Unidad_Superior_Directa,
    uj.Nivel_Jerarquia + 1,
    CAST(uj.Ruta_Jerarquia_Nombres || ' > ' || um_hija.Nombre_Unidad AS VARCHAR2(4000 CHAR)),
    CAST(uj.Ruta_Jerarquia_IDs || ',' || um_hija.ID_Unidad AS VARCHAR2(4000 CHAR))
  FROM unidad_militar um_hija
  JOIN UnidadJerarquia uj ON um_hija.ID_Unidad_Superior_Directa = uj.ID_Unidad
  WHERE uj.Nivel_Jerarquia < 15 -- Safety break for recursion
)
SELECT
  uj.ID_Unidad,
  uj.Nombre_Unidad,
  uj.Tipo_Unidad,
  uj.ID_Unidad_Superior,
  (SELECT um_sup.Nombre_Unidad FROM unidad_militar um_sup WHERE um_sup.ID_Unidad = uj.ID_Unidad_Superior) AS Nombre_Unidad_Superior_Directa,
  uj.Nivel_Jerarquia,
  uj.Ruta_Jerarquia_Nombres,
  uj.Ruta_Jerarquia_IDs,
  um_actual.ID_Pais_Afiliacion_Unidad,
  p.Nombre_Pais AS Pais_Afiliacion_Unidad_Nombre,
  um_actual.Fecha_Activacion_Unidad,
  um_actual.Fecha_Desactivacion_Unidad,
  um_actual.Especializacion_Unidad
FROM UnidadJerarquia uj
JOIN unidad_militar um_actual ON uj.ID_Unidad = um_actual.ID_Unidad
LEFT JOIN pais p ON um_actual.ID_Pais_Afiliacion_Unidad = p.ID_Pais;
